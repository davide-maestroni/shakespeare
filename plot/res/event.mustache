/*
 * Copyright 2019 Davide Maestroni
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dm.shakespeare.plot;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import dm.shakespeare.Stage;
import dm.shakespeare.actor.AbstractBehavior;
import dm.shakespeare.actor.Actor;
import dm.shakespeare.actor.Behavior;
import dm.shakespeare.actor.Behavior.Agent;
import dm.shakespeare.actor.Envelop;
import dm.shakespeare.actor.Headers;
import dm.shakespeare.actor.Role;
import dm.shakespeare.concurrent.ExecutorServices;
import dm.shakespeare.function.Observer;
import dm.shakespeare.message.Bounce;
import dm.shakespeare.message.Receipt;
import dm.shakespeare.plot.SettingInfo.Cache;
import dm.shakespeare.plot.Spectator.SpectatorSignal;
import dm.shakespeare.plot.function.Action;
import dm.shakespeare.plot.function.NullaryFunction;
{{#arities}}
import dm.shakespeare.plot.function.{{classPrefix}}Function;
{{/arities}}
import dm.shakespeare.plot.narrator.Narrator;
import dm.shakespeare.util.ConstantConditions;
import dm.shakespeare.util.Iterables;

/**
 * Created by davide-maestroni on 01/22/2019.
 */
public abstract class Event<T> {

  private static final Observer<?> NO_OP = new Observer<Object>() {

    public void accept(final Object value) {
    }
  };

  @NotNull
  public static <T> Event<T> ofEffect(final T effect) {
    final Cache cache = SettingInfo.get().getCache(Event.class);
    Event<T> event = cache.get(effect);
    if (event == null) {
      event = new EffectEvent<T>(effect);
      cache.put(effect, event);
    }
    return event;
  }

  @NotNull
  public static <T> Event<T> ofEvent(
      @NotNull final NullaryFunction<? extends Event<? extends T>> eventCreator) {
    return new FunctionEvent<T>(eventCreator);
  }

  @NotNull
  public static Event<Boolean> ofFalse() {
    return ofEffect(Boolean.FALSE);
  }

  @NotNull
  public static <T> Event<T> ofIncident(@NotNull final Throwable incident) {
    return new IncidentEvent<T>(incident);
  }

  @NotNull
  public static <T> Event<T> ofNull() {
    return ofEffect(null);
  }

  @NotNull
  public static Event<Boolean> ofTrue() {
    return ofEffect(Boolean.TRUE);
  }
{{#arities}}

  @NotNull
  public static <{{#paramTypes}}{{type}}, {{/paramTypes}}R> Event<R> when({{#paramTypes}}@NotNull final Event<? extends {{type}}> {{prefix}}Event, {{/paramTypes}}
      @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Event<? extends R>> effectHandler) {
    return new {{classPrefix}}Event<{{#paramTypes}}{{type}}, {{/paramTypes}}R>({{#paramTypes}}{{prefix}}Event, {{/paramTypes}}effectHandler);
  }
{{/arities}}

  @NotNull
  public static <T, R> Event<R> when(@NotNull final Iterable<? extends Event<? extends T>> events,
      @NotNull final UnaryFunction<? super List<? extends T>, ? extends Event<? extends R>> effectHandler) {
    return new GenericEvent<T, R>(events, effectHandler);
  }
{{#arities}}

  @NotNull
  public static <{{#paramTypes}}{{type}}, {{/paramTypes}}R> Event<R> whenMap({{#paramTypes}}@NotNull final Event<? extends {{type}}> {{prefix}}Event, {{/paramTypes}}
      @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends R> effectHandler) {
    return new {{classPrefix}}MapEvent<{{#paramTypes}}{{type}}, {{/paramTypes}}R>({{#paramTypes}}{{prefix}}Event, {{/paramTypes}}effectHandler);
  }
{{/arities}}

  @NotNull
  public static <T, R> Event<R> whenMap(
      @NotNull final Iterable<? extends Event<? extends T>> events,
      @NotNull final UnaryFunction<? super List<? extends T>, ? extends R> effectHandler) {
    return new GenericMapEvent<T, R>(events, effectHandler);
  }

  static void done(final Object message, @NotNull final Map<String, Sender> senders,
      @NotNull final Agent agent) {
    final Actor self = agent.getSelf();
    for (final Sender sender : senders.values()) {
      sender.getSender().tell(message, sender.getHeaders(), self);
    }
    agent.setBehavior(new DoneBehavior(message));
  }

  static boolean isFalse(@Nullable final Event<?> event) {
    final Cache cache = SettingInfo.get().getCache(Event.class);
    return cache.get(Boolean.FALSE) == event;
  }

  static boolean isNull(@Nullable final Event<?> event) {
    final Cache cache = SettingInfo.get().getCache(Event.class);
    return cache.get(null) == event;
  }

  static boolean isTrue(@Nullable final Event<?> event) {
    final Cache cache = SettingInfo.get().getCache(Event.class);
    return cache.get(Boolean.TRUE) == event;
  }

  private static boolean isSame(@Nullable final Object expected, @Nullable final Object actual) {
    return (expected == actual) || (expected != null) && expected.equals(actual);
  }

  public void cancel() {
    getActor().tell(EventSignal.CANCEL, Headers.empty(), Stage.standIn());
  }

  @NotNull
  public Event<T> eventually(@NotNull final Action eventualAction) {
    return new EventualEvent<T>(this, eventualAction);
  }

  @NotNull
  public Spectator play(@NotNull final EventObserver<? super T> eventObserver) {
    final Actor actor = Stage.back().createActor(new EventObserverRole<T>(getActor(), eventObserver));
    final String actorId = actor.getId();
    getActor().tell(EventSignal.GET, Headers.empty().withReceiptId(actorId).withThreadId(actorId),
        actor);
    return new Spectator(actor);
  }

  @NotNull
  public Spectator play(@Nullable final Observer<? super T> effectObserver,
      @Nullable final Observer<? super Throwable> incidentObserver) {
    return play(new DefaultEventObserver<T>(effectObserver, incidentObserver));
  }

  @NotNull
  @SuppressWarnings("unchecked")
  public <E1 extends Throwable, E2 extends Throwable, E3 extends Throwable> Event<T> resolve(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final Class<? extends E3> thirdType,
      @NotNull final UnaryFunction<? super E1, ? extends Event<T>> incidentObserver) {
    final HashSet<Class<? extends Throwable>> types = new HashSet<Class<? extends Throwable>>();
    types.add(firstType);
    types.add(secondType);
    types.add(thirdType);
    return new ResolveEvent<T>(this, types,
        (UnaryFunction<? super Throwable, ? extends Event<T>>) incidentObserver);
  }

  @NotNull
  @SuppressWarnings("unchecked")
  public <E1 extends Throwable, E2 extends Throwable> Event<T> resolve(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final UnaryFunction<? super E1, ? extends Event<T>> incidentObserver) {
    final HashSet<Class<? extends Throwable>> types = new HashSet<Class<? extends Throwable>>();
    types.add(firstType);
    types.add(secondType);
    return new ResolveEvent<T>(this, types,
        (UnaryFunction<? super Throwable, ? extends Event<T>>) incidentObserver);
  }

  @NotNull
  @SuppressWarnings("unchecked")
  public <E1 extends Throwable> Event<T> resolve(@NotNull final Class<? extends E1> firstType,
      @NotNull final UnaryFunction<? super E1, ? extends Event<T>> incidentObserver) {
    final Set<Class<? extends Throwable>> types =
        Collections.<Class<? extends Throwable>>singleton(firstType);
    return new ResolveEvent<T>(this, types,
        (UnaryFunction<? super Throwable, ? extends Event<T>>) incidentObserver);
  }

  @NotNull
  @SuppressWarnings("unchecked")
  public <E extends Throwable> Event<T> resolve(
      @NotNull final Iterable<? extends Class<? extends E>> incidentTypes,
      @NotNull final UnaryFunction<? super E, ? extends Event<T>> incidentObserver) {
    return new ResolveEvent<T>(this, Iterables.<Class<? extends Throwable>>toSet(incidentTypes),
        (UnaryFunction<? super Throwable, ? extends Event<T>>) incidentObserver);
  }

  @NotNull
  @SuppressWarnings("unchecked")
  public <E1 extends Throwable, E2 extends Throwable, E3 extends Throwable> Event<T> resolveMap(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final Class<? extends E3> thirdType,
      @NotNull final UnaryFunction<? super E1, ? extends T> incidentObserver) {
    final HashSet<Class<? extends Throwable>> types = new HashSet<Class<? extends Throwable>>();
    types.add(firstType);
    types.add(secondType);
    types.add(thirdType);
    return new ResolveMapEvent<T>(this, types,
        (UnaryFunction<? super Throwable, ? extends T>) incidentObserver);
  }

  @NotNull
  @SuppressWarnings("unchecked")
  public <E1 extends Throwable, E2 extends Throwable> Event<T> resolveMap(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final UnaryFunction<? super E1, ? extends T> incidentObserver) {
    final HashSet<Class<? extends Throwable>> types = new HashSet<Class<? extends Throwable>>();
    types.add(firstType);
    types.add(secondType);
    return new ResolveMapEvent<T>(this, types,
        (UnaryFunction<? super Throwable, ? extends T>) incidentObserver);
  }

  @NotNull
  @SuppressWarnings("unchecked")
  public <E1 extends Throwable> Event<T> resolveMap(
      @NotNull final Class<? extends E1> firstType,
      @NotNull final UnaryFunction<? super E1, ? extends T> incidentObserver) {
    final Set<Class<? extends Throwable>> types =
        Collections.<Class<? extends Throwable>>singleton(firstType);
    return new ResolveMapEvent<T>(this, types,
        (UnaryFunction<? super Throwable, ? extends T>) incidentObserver);
  }

  @NotNull
  @SuppressWarnings("unchecked")
  public <E extends Throwable> Event<T> resolveMap(
      @NotNull final Iterable<? extends Class<? extends E>> incidentTypes,
      @NotNull final UnaryFunction<? super E, ? extends T> incidentObserver) {
    return new ResolveMapEvent<T>(this, Iterables.<Class<? extends Throwable>>toSet(incidentTypes),
        (UnaryFunction<? super Throwable, ? extends T>) incidentObserver);
  }

  @NotNull
  public Event<T> scheduleWithDelay(final long delay, @NotNull final TimeUnit unit) {
    return new ScheduleWithDelayEvent<T>(this, delay, unit);
  }

  @NotNull
  public <R> Event<R> then(
      @NotNull final UnaryFunction<? super T, ? extends Event<R>> effectHandler) {
    return when(this, effectHandler);
  }

  @NotNull
  public <R> Event<R> thenMap(
      @NotNull final UnaryFunction<? super T, ? extends R> effectHandler) {
    return whenMap(this, effectHandler);
  }

  @NotNull
  public Event<T> watch(@NotNull final EventObserver<? super T> effectHandler) {
    return new WatchEvent<T>(this, effectHandler);
  }

  @NotNull
  public Event<T> watch(@Nullable final Observer<? super T> effectObserver,
      @Nullable final Observer<? super Throwable> incidentObserver) {
    return watch(new DefaultEventObserver<T>(effectObserver, incidentObserver));
  }

  @NotNull
  abstract Actor getActor();

  public static class EventNarrator<T> extends Event<T> implements Narrator<T> {

    private final Actor actor;
    private final AtomicBoolean isClosed = new AtomicBoolean();
    private final BlockingQueue<Object> queue;
    private final HashMap<String, Sender> senders = new HashMap<String, Sender>();

    private volatile Throwable exception;

    EventNarrator(@NotNull final BlockingQueue<Object> queue) {
      this.queue = ConstantConditions.notNull("queue", queue);
      actor = Stage.back().createActor(new PlotRole(SettingInfo.get()) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new InitBehavior();
        }
      });
    }

    public void close() {
      if (!isClosed.getAndSet(true)) {
        if (exception == null) {
          exception = new NarrationStoppedException();
        }
        if (queue.isEmpty()) {
          actor.tell(NarratorSignal.AVAILABLE, Headers.empty(), Stage.standIn());
        }
      }
    }

    public boolean report(@NotNull final Throwable incident, final long timeout,
        @NotNull final TimeUnit unit) throws InterruptedException {
      return enqueue(new Conflict(incident), timeout, unit);
    }

    public boolean tell(final T effect, final long timeout, @NotNull final TimeUnit unit) throws
        InterruptedException {
      return enqueue((effect != null) ? effect : NarratorSignal.NULL, timeout, unit);
    }

    @NotNull
    Actor getActor() {
      return actor;
    }

    private void cancel(@NotNull final Throwable cause) {
      if (exception == null) {
        exception = cause;
      }
      queue.clear();
    }

    private boolean enqueue(@NotNull final Object resolution, final long timeout,
        @NotNull final TimeUnit unit) throws InterruptedException {
      final Throwable exception = this.exception;
      if (exception != null) {
        if (exception instanceof RuntimeException) {
          throw (RuntimeException) exception;

        } else {
          throw new PlotFailureException(exception);
        }
      }
      final BlockingQueue<Object> queue = this.queue;
      final boolean wasEmpty = queue.isEmpty();
      if (queue.offer(resolution, timeout, unit)) {
        close();
        if (wasEmpty) {
          actor.tell(NarratorSignal.AVAILABLE, Headers.empty(), Stage.standIn());
        }
        return true;
      }
      return false;
    }

    private class InitBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == EventSignal.GET) {
          final Actor sender = envelop.getSender();
          final Headers headers = envelop.getHeaders().threadOnly();
          Object effect = queue.poll();
          if (effect != null) {
            close();
            if (effect == NarratorSignal.NULL) {
              effect = null;
            }
            sender.tell(effect, headers, agent.getSelf());
            agent.setBehavior(new DoneBehavior(effect));

          } else if (isClosed.get()) {
            effect = new Conflict(new NarrationStoppedException());
            sender.tell(effect, headers, agent.getSelf());
            agent.setBehavior(new DoneBehavior(effect));

          } else {
            senders.put(headers.getThreadId(), new Sender(sender, headers));
            agent.setBehavior(new InputBehavior());
          }

        } else if (message == EventSignal.CANCEL) {
          final Conflict conflict = Conflict.ofCancel();
          cancel(conflict.getIncident());
          agent.setBehavior(new DoneBehavior(conflict));
        }
        envelop.preventReceipt();
      }
    }

    private class InputBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == EventSignal.GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          senders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == EventSignal.CANCEL) {
          final Conflict conflict = Conflict.ofCancel();
          cancel(conflict.getIncident());
          agent.setBehavior(new DoneBehavior(conflict));

        } else if (message == NarratorSignal.AVAILABLE) {
          boolean closed = false;
          Object effect = queue.poll();
          if (effect != null) {
            closed = true;
            close();
            if (effect == NarratorSignal.NULL) {
              effect = null;
            }

          } else if (isClosed.get()) {
            closed = true;
            effect = new Conflict(new NarrationStoppedException());
          }

          if (closed) {
            final Actor self = agent.getSelf();
            for (final Sender sender : senders.values()) {
              sender.getSender().tell(effect, sender.getHeaders(), self);
            }
            agent.setBehavior(new DoneBehavior(effect));
          }
        }
        envelop.preventReceipt();
      }
    }
  }

  static class ActorEvent<T> extends AbstractEvent<T> {

    private final List<Actor> actors;

    ActorEvent(@NotNull final Actor actor) {
      super(1);
      actors = Collections.singletonList(actor);
    }

    @NotNull
    List<Actor> getInputActors() {
      return actors;
    }
  }

  static class DefaultEventObserver<T> implements EventObserver<T> {

    private final Observer<Object> effectObserver;
    private final Observer<Object> incidentObserver;

    @SuppressWarnings("unchecked")
    DefaultEventObserver(@Nullable final Observer<? super T> effectObserver,
        @Nullable final Observer<? super Throwable> incidentObserver) {
      this.effectObserver = (Observer<Object>) ((effectObserver != null) ? effectObserver : NO_OP);
      this.incidentObserver =
          (Observer<Object>) ((incidentObserver != null) ? incidentObserver : NO_OP);
    }

    public void onEffect(final T effect) throws Exception {
      effectObserver.accept(effect);
    }

    public void onIncident(@NotNull final Throwable incident) throws Exception {
      incidentObserver.accept(incident);
    }
  }

  enum EventSignal {
    GET, CANCEL
  }

  enum NarratorSignal {
    AVAILABLE, NULL
  }

  private abstract static class AbstractEvent<T> extends Event<T> {

    private final Actor actor;
    private final Headers headers;
    private final HashMap<Actor, Headers> inputActors = new HashMap<Actor, Headers>();
    private final String inputThread;
    private final Object[] inputs;
    private final Headers outputHeaders;
    private final HashMap<String, Sender> senders = new HashMap<String, Sender>();
    private final SettingInfo settingInfo;

    private Conflict conflict;
    private int inputCount;

    private AbstractEvent(final int numInputs) {
      inputs = new Object[numInputs];
      final SettingInfo settingInfo = (this.settingInfo = SettingInfo.get());
      final String actorId = (actor = Stage.back().createActor(new PlotRole(settingInfo) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new InitBehavior();
        }
      })).getId();
      final Headers headers = (this.headers = Headers.empty().withReceiptId(actorId));
      inputThread = actorId + ":input";
      outputHeaders = headers.withThreadId(actorId + ":output");
    }

    void endAction() throws Exception {
    }

    @Nullable
    Actor getConflictActor(@NotNull final Conflict conflict, @NotNull final Agent agent) throws
        Exception {
      putConflict(conflict, agent);
      return null;
    }

    @NotNull
    abstract List<Actor> getInputActors();

    @Nullable
    Actor getOutputActor(@NotNull final Object[] inputs, @NotNull final Agent agent) throws
        Exception {
      putEffect(inputs[0], agent);
      return null;
    }

    @NotNull
    SettingInfo getSettingInfo() {
      return settingInfo;
    }

    void putConflict(@NotNull final Conflict conflict, @NotNull final Agent agent) {
      fail(conflict, agent);
    }

    void putEffect(final Object effect, @NotNull final Agent agent) {
      done(effect, agent);
    }

    private void cancelInputActors(@NotNull final Agent agent) {
      final Actor self = agent.getSelf();
      for (final Actor actor : getInputActors()) {
        actor.tell(EventSignal.CANCEL, Headers.empty(), self);
      }
    }

    private void conflict(@NotNull final Conflict conflict, @NotNull final Agent agent) {
      try {
        final Actor conflictActor = getConflictActor(conflict, agent);
        if (conflictActor != null) {
          conflictActor.tell(EventSignal.GET, outputHeaders, agent.getSelf());
          agent.setBehavior(new OutputBehavior());
        }

      } catch (final Throwable t) {
        fail(new Conflict(t), agent);
        if (t instanceof InterruptedException) {
          Thread.currentThread().interrupt();

        } else if (t instanceof Error) {
          // rethrow errors
          throw (Error) t;
        }
      }
    }

    private void done(Object message, @NotNull final Agent agent) {
      Throwable error = null;
      try {
        endAction();

      } catch (final Throwable t) {
        error = t;
        message = new Conflict(t);
        if (t instanceof InterruptedException) {
          Thread.currentThread().interrupt();
        }
      }
      done(message, senders, agent);
      if (error instanceof Error) {
        // rethrow errors
        throw (Error) error;
      }
    }

    private void fail(@NotNull Conflict conflict, @NotNull final Agent agent) {
      Throwable error = null;
      try {
        endAction();

      } catch (final Throwable t) {
        error = t;
        conflict = new Conflict(t);
        if (t instanceof InterruptedException) {
          Thread.currentThread().interrupt();
        }
      }
      done(conflict, senders, agent);
      if (error instanceof Error) {
        // rethrow errors
        throw (Error) error;
      }
    }

    private void getInputActors(@NotNull final Agent agent) {
      final Actor self = agent.getSelf();
      final HashMap<Actor, Headers> inputActors = this.inputActors;
      if (inputActors.isEmpty()) {
        final Headers headers = this.headers;
        final String inputThread = this.inputThread;
        final StringBuilder builder = new StringBuilder();
        for (final Actor actor : getInputActors()) {
          final String threadId = inputThread + builder.append('#').toString();
          final Headers inputHeaders = headers.withThreadId(threadId);
          inputActors.put(actor, inputHeaders);
          actor.tell(EventSignal.GET, inputHeaders, self);
        }

      } else {
        for (final Entry<Actor, Headers> entry : inputActors.entrySet()) {
          entry.getKey().tell(EventSignal.GET, entry.getValue(), self);
        }
      }
    }

    private class CancelBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == EventSignal.GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          senders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (isSame(outputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
          fail(Conflict.ofCancel(), agent);

        } else {
          final String thread = envelop.getHeaders().getThreadId();
          if ((thread != null) && thread.startsWith(inputThread)) {
            if (++inputCount == inputs.length) {
              final Conflict conflict = Conflict.ofCancel();
              try {
                final Actor conflictActor = getConflictActor(conflict, agent);
                if (conflictActor != null) {
                  conflictActor.tell(EventSignal.CANCEL, Headers.empty(), agent.getSelf());
                  fail(conflict, agent);
                }

              } catch (final Throwable t) {
                fail(new Conflict(t), agent);
                if (t instanceof InterruptedException) {
                  Thread.currentThread().interrupt();

                } else if (t instanceof Error) {
                  // rethrow errors
                  throw (Error) t;
                }
              }
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    private class InitBehavior extends AbstractBehavior {

      public void onMessage(Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == EventSignal.GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          senders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
          getInputActors(agent);
          agent.setBehavior(new InputBehavior());

        } else if (message == EventSignal.CANCEL) {
          cancelInputActors(agent);
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class InputBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == EventSignal.GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          senders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == EventSignal.CANCEL) {
          cancelInputActors(agent);
          agent.setBehavior(new CancelBehavior());

        } else {
          final String inputThread = AbstractEvent.this.inputThread;
          final String thread = envelop.getHeaders().getThreadId();
          if ((thread != null) && thread.startsWith(inputThread)) {
            if (message instanceof Conflict) {
              if (conflict == null) {
                conflict = (Conflict) message;
              }

              if (++inputCount == inputs.length) {
                conflict((Conflict) message, agent);
              }

            } else if (message instanceof Bounce) {
              final Conflict conflict = Conflict.ofBounce((Bounce) message);
              if (AbstractEvent.this.conflict == null) {
                AbstractEvent.this.conflict = conflict;
              }

              if (++inputCount == inputs.length) {
                conflict(conflict, agent);
              }

            } else {
              final int index = thread.length() - inputThread.length() - 1;
              final Object[] inputs = AbstractEvent.this.inputs;
              if ((index >= 0) && (index < inputs.length)) {
                inputs[index] = message;
                if (++inputCount == inputs.length) {
                  if (conflict != null) {
                    conflict(conflict, agent);

                  } else {
                    try {
                      final Actor outputActor = getOutputActor(inputs, agent);
                      if (outputActor != null) {
                        outputActor.tell(EventSignal.GET, outputHeaders, agent.getSelf());
                        agent.setBehavior(new OutputBehavior());
                      }

                    } catch (final Throwable t) {
                      fail(new Conflict(t), agent);
                      if (t instanceof InterruptedException) {
                        Thread.currentThread().interrupt();

                      } else if (t instanceof Error) {
                        // rethrow errors
                        throw (Error) t;
                      }
                    }
                  }
                }

              } else {
                conflict(Conflict.ofCancel(), agent);
              }
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    private class OutputBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == EventSignal.GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          senders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == EventSignal.CANCEL) {
          cancelInputActors(agent);
          agent.setBehavior(new CancelBehavior());

        } else {
          if (isSame(outputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            if (message instanceof Conflict) {
              fail((Conflict) message, agent);

            } else if (message instanceof Bounce) {
              fail(Conflict.ofBounce((Bounce) message), agent);

            } else {
              done(message, agent);
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class DoneBehavior extends AbstractBehavior {

    private final Object effect;

    private DoneBehavior(final Object effect) {
      this.effect = effect;
    }

    public void onMessage(final Object message, @NotNull final Envelop envelop,
        @NotNull final Agent agent) {
      if (message == EventSignal.GET) {
        envelop.getSender().tell(effect, envelop.getHeaders().threadOnly(), agent.getSelf());
      }
      envelop.preventReceipt();
    }
  }

  private static class EffectEvent<T> extends Event<T> {

    private final Actor actor;

    private EffectEvent(final T effect) {
      actor = Stage.back().createActor(new LocalPlotRole(SettingInfo.get()) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new DoneBehavior(effect);
        }
      });
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class EventObserverRole<T> extends Role {

    private final Actor eventActor;
    private final EventObserver<? super T> eventObserver;
    private final SettingInfo settingInfo;

    private EventObserverRole(@NotNull final Actor eventActor,
        @NotNull final EventObserver<? super T> eventObserver) {
      this.eventActor = ConstantConditions.notNull("eventActor", eventActor);
      this.eventObserver = ConstantConditions.notNull("eventObserver", eventObserver);
      this.settingInfo = SettingInfo.getIfPresent();
    }

    @NotNull
    public Behavior getBehavior(@NotNull final String id) {
      return new AbstractBehavior() {

        private Object effect;
        private boolean isPaused;

        @SuppressWarnings("unchecked")
        public void onMessage(final Object message, @NotNull final Envelop envelop,
            @NotNull final Agent agent) throws Exception {
          if (message instanceof Conflict) {
            if (isPaused) {
              effect = message;

            } else {
              eventObserver.onIncident(((Conflict) message).getIncident());
              agent.getSelf().dismiss();
            }

          } else if (message instanceof Bounce) {
            if (isPaused) {
              effect = new Conflict(PlotFailureException.getOrNew((Bounce) message));

            } else {
              eventObserver.onIncident(PlotFailureException.getOrNew((Bounce) message));
              agent.getSelf().dismiss();
            }

          } else if (message == SpectatorSignal.PAUSE) {
            isPaused = true;

          } else if ((message == SpectatorSignal.RESUME) && isPaused) {
            final Object effect = this.effect;
            if (effect instanceof Conflict) {
              eventObserver.onIncident(((Conflict) effect).getIncident());

            } else {
              eventObserver.onEffect((T) message);
            }
            agent.getSelf().dismiss();

          } else if (message == SpectatorSignal.CANCEL) {
            eventActor.tell(EventSignal.CANCEL, Headers.empty(), agent.getSelf());

          } else if (message == SpectatorSignal.CANCEL_AND_DISMISS) {
            final Actor self = agent.getSelf();
            eventActor.tell(EventSignal.CANCEL, Headers.empty(), self);
            self.dismiss();

          } else if (!(message instanceof Receipt)) {
            if (isPaused) {
              effect = message;

            } else {
              eventObserver.onEffect((T) message);
              agent.getSelf().dismiss();
            }
          }
          envelop.preventReceipt();
        }
      };
    }

    @NotNull
    @Override
    public ExecutorService getExecutorService(@NotNull final String id) {
      return (settingInfo != null) ? settingInfo.getExecutor() : ExecutorServices.localExecutor();
    }
  }

  private static class EventualEvent<T> extends AbstractEvent<T> {

    private final List<Actor> actors;
    private final Action eventualAction;

    private EventualEvent(@NotNull final Event<T> event, @NotNull final Action eventualAction) {
      super(1);
      actors = Collections.singletonList(event.getActor());
      this.eventualAction = ConstantConditions.notNull("eventualAction", eventualAction);
    }

    @Override
    void endAction() throws Exception {
      SettingInfo.set(getSettingInfo());
      try {
        eventualAction.run();

      } finally {
        SettingInfo.unset();
      }
    }

    @NotNull
    List<Actor> getInputActors() {
      return actors;
    }
  }

  private static class FunctionEvent<T> extends AbstractEvent<T> {

    private final NullaryFunction<? extends Event<? extends T>> eventCreator;

    private List<Actor> actors;

    private FunctionEvent(
        @NotNull final NullaryFunction<? extends Event<? extends T>> eventCreator) {
      super(1);
      this.eventCreator = ConstantConditions.notNull("eventCreator", eventCreator);
    }

    @NotNull
    List<Actor> getInputActors() {
      if (actors == null) {
        Event<? extends T> event;
        SettingInfo.set(getSettingInfo());
        try {
          event = eventCreator.call();
          if (event == null) {
            event = ofNull();
          }

        } catch (final Throwable t) {
          event = ofIncident(t);
          if (t instanceof InterruptedException) {
            Thread.currentThread().interrupt();

          } else if (t instanceof Error) {
            // rethrow errors
            throw (Error) t;
          }

        } finally {
          SettingInfo.unset();
        }
        actors = Collections.singletonList(event.getActor());
      }
      return actors;
    }
  }

  private static class GenericEvent<T, R> extends AbstractEvent<R> {

    private final List<Actor> actors;
    private final UnaryFunction<? super List<? extends T>, ? extends Event<? extends R>> effectHandler;

    private GenericEvent(@NotNull final Iterable<? extends Event<? extends T>> events,
        @NotNull final UnaryFunction<? super List<? extends T>, ? extends Event<? extends R>> effectHandler) {
      super(Iterables.size(events));
      final ArrayList<Actor> actors = new ArrayList<Actor>();
      for (final Event<? extends T> event : events) {
        actors.add(event.getActor());
      }
      this.actors = actors;
      this.effectHandler = ConstantConditions.notNull("effectHandler", effectHandler);
    }

    @NotNull
    List<Actor> getInputActors() {
      return actors;
    }

    @Nullable
    @Override
    @SuppressWarnings("unchecked")
    Actor getOutputActor(@NotNull final Object[] inputs, @NotNull final Agent agent) throws
        Exception {
      SettingInfo.set(getSettingInfo());
      try {
        final ArrayList<T> inputList = new ArrayList<T>();
        for (final Object input : inputs) {
          inputList.add((T) input);
        }
        final Event<? extends R> event = effectHandler.call(inputList);
        return ((event != null) ? event : ofNull()).getActor();

      } finally {
        SettingInfo.unset();
      }
    }
  }

  private static class GenericMapEvent<T, R> extends AbstractEvent<R> {

    private final List<Actor> actors;
    private final UnaryFunction<? super List<? extends T>, ? extends R> effectHandler;

    private GenericMapEvent(@NotNull final Iterable<? extends Event<? extends T>> events,
        @NotNull final UnaryFunction<? super List<? extends T>, ? extends R> effectHandler) {
      super(Iterables.size(events));
      final ArrayList<Actor> actors = new ArrayList<Actor>();
      for (final Event<? extends T> event : events) {
        actors.add(event.getActor());
      }
      this.actors = actors;
      this.effectHandler = ConstantConditions.notNull("effectHandler", effectHandler);
    }

    @NotNull
    List<Actor> getInputActors() {
      return actors;
    }

    @Nullable
    @Override
    @SuppressWarnings("unchecked")
    Actor getOutputActor(@NotNull final Object[] inputs, @NotNull final Agent agent) throws
        Exception {
      SettingInfo.set(getSettingInfo());
      try {
        final ArrayList<T> inputList = new ArrayList<T>();
        for (final Object input : inputs) {
          inputList.add((T) input);
        }
        final R effect = effectHandler.call(inputList);
        putEffect(effect, agent);
        return null;

      } finally {
        SettingInfo.unset();
      }
    }
  }

  private static class IncidentEvent<T> extends Event<T> {

    private final Actor actor;

    private IncidentEvent(@NotNull final Throwable incident) {
      final Conflict conflict = new Conflict(incident);
      actor = Stage.back().createActor(new LocalPlotRole(SettingInfo.get()) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new DoneBehavior(conflict);
        }
      });
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class ResolveEvent<T> extends AbstractEvent<T> {

    private final List<Actor> actors;
    private final UnaryFunction<? super Throwable, ? extends Event<T>> incidentHandler;
    private final Set<Class<? extends Throwable>> incidentTypes;

    private ResolveEvent(@NotNull final Event<? extends T> event,
        @NotNull final Set<Class<? extends Throwable>> incidentTypes,
        @NotNull final UnaryFunction<? super Throwable, ? extends Event<T>> incidentHandler) {
      super(1);
      actors = Collections.singletonList(event.getActor());
      this.incidentTypes = ConstantConditions.notNullElements("incidentTypes", incidentTypes);
      this.incidentHandler = ConstantConditions.notNull("incidentHandler", incidentHandler);
    }

    @Nullable
    @Override
    Actor getConflictActor(@NotNull final Conflict conflict, @NotNull final Agent agent) throws
        Exception {
      final Throwable incident = conflict.getIncident();
      for (final Class<? extends Throwable> incidentType : incidentTypes) {
        if (incidentType.isInstance(incident)) {
          SettingInfo.set(getSettingInfo());
          try {
            final Event<T> event = incidentHandler.call(incident);
            return ((event != null) ? event : ofNull()).getActor();

          } finally {
            SettingInfo.unset();
          }
        }
      }
      return super.getConflictActor(conflict, agent);
    }

    @NotNull
    List<Actor> getInputActors() {
      return actors;
    }
  }

  private static class ResolveMapEvent<T> extends AbstractEvent<T> {

    private final List<Actor> actors;
    private final UnaryFunction<? super Throwable, ? extends T> incidentHandler;
    private final Set<Class<? extends Throwable>> incidentTypes;

    private ResolveMapEvent(@NotNull final Event<? extends T> event,
        @NotNull final Set<Class<? extends Throwable>> incidentTypes,
        @NotNull final UnaryFunction<? super Throwable, ? extends T> incidentHandler) {
      super(1);
      actors = Collections.singletonList(event.getActor());
      this.incidentTypes = ConstantConditions.notNullElements("incidentTypes", incidentTypes);
      this.incidentHandler = ConstantConditions.notNull("incidentHandler", incidentHandler);
    }

    @Nullable
    @Override
    Actor getConflictActor(@NotNull final Conflict conflict, @NotNull final Agent agent) throws
        Exception {
      final Throwable incident = conflict.getIncident();
      for (final Class<? extends Throwable> incidentType : incidentTypes) {
        if (incidentType.isInstance(incident)) {
          SettingInfo.set(getSettingInfo());
          try {
            final T effect = incidentHandler.call(incident);
            putEffect(effect, agent);
            return null;

          } finally {
            SettingInfo.unset();
          }
        }
      }
      return super.getConflictActor(conflict, agent);
    }

    @NotNull
    List<Actor> getInputActors() {
      return actors;
    }
  }

  private static class ScheduleWithDelayEvent<T> extends Event<T> implements Runnable {

    private final Actor actor;
    private final long delay;
    private final Actor inputActor;
    private final Headers inputHeaders;
    private final HashMap<String, Sender> senders = new HashMap<String, Sender>();
    private final TimeUnit unit;

    private boolean inputPending;
    private ScheduledFuture<?> scheduledFuture;

    private ScheduleWithDelayEvent(@NotNull final Event<? extends T> event, final long delay,
        @NotNull final TimeUnit unit) {
      inputActor = event.getActor();
      this.delay = ConstantConditions.positive("delay", delay);
      this.unit = ConstantConditions.notNull("unit", unit);
      final String actorId = (actor = Stage.back().createActor(new PlotRole(SettingInfo.get()) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new InitBehavior();
        }
      })).getId();
      inputHeaders = Headers.empty().withReceiptId(actorId).withThreadId(actorId + ":input");
    }

    public void run() {
      inputPending = true;
      inputActor.tell(EventSignal.GET, inputHeaders, actor);
    }

    private void done(Object message, @NotNull final Agent agent) {
      final ScheduledFuture<?> scheduledFuture = this.scheduledFuture;
      if (scheduledFuture != null) {
        scheduledFuture.cancel(false);
      }
      done(message, senders, agent);
    }

    private void fail(@NotNull final Conflict conflict, @NotNull final Agent agent) {
      final ScheduledFuture<?> scheduledFuture = this.scheduledFuture;
      if (scheduledFuture != null) {
        scheduledFuture.cancel(false);
      }
      done(conflict, senders, agent);
    }

    private class CancelBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == EventSignal.GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          senders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class InitBehavior extends AbstractBehavior {

      public void onMessage(Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == EventSignal.GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          senders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
          scheduledFuture = agent.getScheduledExecutorService()
              .schedule(ScheduleWithDelayEvent.this, delay, unit);
          agent.setBehavior(new InputBehavior());

        } else if (message == EventSignal.CANCEL) {
          inputActor.tell(EventSignal.CANCEL, Headers.empty(), actor);
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class InputBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == EventSignal.GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          senders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == EventSignal.CANCEL) {
          inputActor.tell(EventSignal.CANCEL, Headers.empty(), actor);
          if (inputPending) {
            agent.setBehavior(new CancelBehavior());

          } else {
            fail(Conflict.ofCancel(), agent);
          }

        } else if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
          if (message instanceof Conflict) {
            fail((Conflict) message, agent);

          } else if (message instanceof Bounce) {
            fail(Conflict.ofBounce((Bounce) message), agent);

          } else {
            done(message, agent);
          }
        }
        envelop.preventReceipt();
      }
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class Sender {

    private final Headers headers;
    private final Actor sender;

    private Sender(@NotNull final Actor sender, @NotNull final Headers headers) {
      this.sender = sender;
      this.headers = headers;
    }

    @NotNull
    Headers getHeaders() {
      return headers;
    }

    @NotNull
    Actor getSender() {
      return sender;
    }
  }
{{#arities}}

  private static class {{classPrefix}}Event<{{#paramTypes}}{{type}}, {{/paramTypes}}R> extends AbstractEvent<R> {

    private final List<Actor> actors;
    private final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Event<? extends R>> effectHandler;

    @SuppressWarnings("ArraysAsListWithZeroOrOneArgument")
    private {{classPrefix}}Event({{#paramTypes}}@NotNull final Event<? extends {{type}}> {{prefix}}Event, {{/paramTypes}}
        @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Event<? extends R>> effectHandler) {
      super({{paramNum}});
      actors = Arrays.asList({{#paramTypes}}{{prefix}}Event.getActor(){{#hasNext}}, {{/hasNext}}{{/paramTypes}});
      this.effectHandler = ConstantConditions.notNull("effectHandler", effectHandler);
    }

    @NotNull
    List<Actor> getInputActors() {
      return actors;
    }

    @Nullable
    @Override
    @SuppressWarnings("unchecked")
    Actor getOutputActor(@NotNull final Object[] inputs, @NotNull final Agent agent) throws
        Exception {
      SettingInfo.set(getSettingInfo());
      try {
        final Event<? extends R> event = effectHandler.call({{#paramTypes}}({{type}}) inputs[{{index}}]{{#hasNext}}, {{/hasNext}}{{/paramTypes}});
        return ((event != null) ? event : ofNull()).getActor();

      } finally {
        SettingInfo.unset();
      }
    }
  }

  private static class {{classPrefix}}MapEvent<{{#paramTypes}}{{type}}, {{/paramTypes}}R> extends AbstractEvent<R> {

    private final List<Actor> actors;
    private final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends R> effectHandler;

    @SuppressWarnings("ArraysAsListWithZeroOrOneArgument")
    private {{classPrefix}}MapEvent({{#paramTypes}}@NotNull final Event<? extends {{type}}> {{prefix}}Event, {{/paramTypes}}
        @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends R> effectHandler) {
      super({{paramNum}});
      actors = Arrays.asList({{#paramTypes}}{{prefix}}Event.getActor(){{#hasNext}}, {{/hasNext}}{{/paramTypes}});
      this.effectHandler = ConstantConditions.notNull("effectHandler", effectHandler);
    }

    @NotNull
    List<Actor> getInputActors() {
      return actors;
    }

    @Nullable
    @Override
    @SuppressWarnings("unchecked")
    Actor getOutputActor(@NotNull final Object[] inputs, @NotNull final Agent agent) throws
        Exception {
      SettingInfo.set(getSettingInfo());
      try {
        final R effect = effectHandler.call({{#paramTypes}}({{type}}) inputs[{{index}}]{{#hasNext}}, {{/hasNext}}{{/paramTypes}});
        putEffect(effect, agent);
        return null;

      } finally {
        SettingInfo.unset();
      }
    }
  }
{{/arities}}

  private static class WatchEvent<T> extends AbstractEvent<T> {

    private final List<Actor> actors;
    private final EventObserver<? super T> eventObserver;

    private WatchEvent(@NotNull final Event<? extends T> event,
        @NotNull final EventObserver<? super T> eventObserver) {
      super(1);
      actors = Collections.singletonList(event.getActor());
      this.eventObserver = ConstantConditions.notNull("eventObserver", eventObserver);
    }

    @Nullable
    @Override
    @SuppressWarnings("unchecked")
    Actor getOutputActor(@NotNull final Object[] inputs, @NotNull final Agent agent) throws
        Exception {
      SettingInfo.set(getSettingInfo());
      try {
        eventObserver.onEffect((T) inputs[0]);

      } finally {
        SettingInfo.unset();
      }
      return super.getOutputActor(inputs, agent);
    }

    @Nullable
    @Override
    Actor getConflictActor(@NotNull final Conflict conflict, @NotNull final Agent agent) throws
        Exception {
      SettingInfo.set(getSettingInfo());
      try {
        eventObserver.onIncident(conflict.getIncident());

      } finally {
        SettingInfo.unset();
      }
      return super.getConflictActor(conflict, agent);
    }

    @NotNull
    List<Actor> getInputActors() {
      return actors;
    }
  }
}
