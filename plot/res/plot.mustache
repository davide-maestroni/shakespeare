/*
 * Copyright 2019 Davide Maestroni
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dm.shakespeare.plot;

import org.jetbrains.annotations.NotNull;

import java.io.ObjectStreamException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.WeakHashMap;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import dm.shakespeare.Stage;
import dm.shakespeare.actor.AbstractBehavior;
import dm.shakespeare.actor.Actor;
import dm.shakespeare.actor.Behavior;
import dm.shakespeare.actor.BehaviorBuilder.Handler;
import dm.shakespeare.actor.Envelop;
import dm.shakespeare.actor.Headers;
import dm.shakespeare.actor.Role;
import dm.shakespeare.actor.SerializableRole;
import dm.shakespeare.concurrent.ExecutorServices;
import dm.shakespeare.log.Logger;
import dm.shakespeare.message.Bounce;
import dm.shakespeare.plot.Event.ActorEvent;
import dm.shakespeare.plot.Event.EventNarrator;
import dm.shakespeare.plot.Story.ActorStory;
import dm.shakespeare.plot.Story.StoryNarrator;
import dm.shakespeare.plot.config.BuildConfig;
import dm.shakespeare.plot.function.NullaryFunction;
{{#arities}}
import dm.shakespeare.plot.function.{{classPrefix}}Function;
{{/arities}}
import dm.shakespeare.plot.memory.ListMemory;
import dm.shakespeare.plot.memory.Memory;
import dm.shakespeare.util.ConstantConditions;
import dm.shakespeare.util.WeakValueHashMap;

/**
 * Created by davide-maestroni on 01/25/2019.
 */
public class Plot {

  private static final DefaultSetting DEFAULT_SETTING = new DefaultSetting();

  private final Actor actor;
  private final SettingInfo settingInfo;

  public Plot(@NotNull final Stage stage) {
    this(stage, DEFAULT_SETTING);
  }

  public Plot(@NotNull final Stage stage, @NotNull final Setting setting) {
    actor = stage.createActor(new PlotFactoryRole(setting));
    settingInfo = new SettingInfo(ExecutorServices.localExecutor(), Role.defaultLogger(this));
  }

  public Plot(@NotNull final Stage stage, @NotNull final Setting setting,
      @NotNull final Logger logger) {
    actor = stage.createActor(new PlotFactoryRole(setting));
    settingInfo = new SettingInfo(ExecutorServices.localExecutor(), logger);
  }

  @NotNull
  public <T> EventNarrator<T> event() {
    return event(new LinkedBlockingQueue<Object>());
  }

  @NotNull
  public <T> EventNarrator<T> event(@NotNull final BlockingQueue<Object> queue) {
    SettingInfo.set(settingInfo);
    try {
      return new EventNarrator<T>(queue);

    } finally {
      SettingInfo.unset();
    }
  }

  @NotNull
  public <T> Event<T> event(
      @NotNull final NullaryFunction<? extends Event<? extends T>> eventCreator) {
    final Actor actor = this.actor;
    SettingInfo.set(settingInfo);
    try {
      final ActorEvent<T> event = new ActorEvent<T>(actor);
      actor.tell(new CreateNullaryEvent(eventCreator), Headers.empty(), event.getActor());
      return event;

    } finally {
      SettingInfo.unset();
    }
  }

  @NotNull
  public <T, R> Event<R> event(@NotNull final Iterable<? extends Event<? extends T>> events,
      @NotNull final UnaryFunction<? super List<? extends Event<? extends T>>, ? extends Event<? extends R>> eventCreator) {
    final Actor actor = this.actor;
    SettingInfo.set(settingInfo);
    try {
      final ActorEvent<R> event = new ActorEvent<R>(actor);
      final Headers headers = Headers.empty().withThreadId(event.getActor().getId());
      for (final Event<? extends T> anEvent : events) {
        actor.tell(PlotSignal.CREATE_PARAM, headers, anEvent.getActor());
      }
      actor.tell(new CreateEvent<T>(eventCreator), headers, event.getActor());
      return event;

    } finally {
      SettingInfo.unset();
    }
  }
{{#arities}}

  @NotNull
  public <{{#paramTypes}}{{type}} extends Event<?>, {{/paramTypes}}R> Event<R> event({{#paramTypes}}@NotNull final {{type}} {{prefix}}Event, {{/paramTypes}}
      @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Event<? extends R>> eventCreator) {
    final Actor actor = this.actor;
    SettingInfo.set(settingInfo);
    try {
      final ActorEvent<R> event = new ActorEvent<R>(actor);
      final Headers headers = Headers.empty().withThreadId(event.getActor().getId());
{{#paramTypes}}      actor.tell(PlotSignal.CREATE_PARAM, headers, {{prefix}}Event.getActor());
{{/paramTypes}}
      actor.tell(new Create{{classPrefix}}Event<{{#paramTypes}}{{type}}{{#hasNext}}, {{/hasNext}}{{/paramTypes}}>(eventCreator), headers, event.getActor());
      return event;

    } finally {
      SettingInfo.unset();
    }
  }
{{/arities}}

  @NotNull
  public <T> StoryNarrator<T> story() {
    return story(new LinkedBlockingQueue<Object>());
  }

  @NotNull
  public <T> StoryNarrator<T> story(@NotNull final BlockingQueue<Object> queue) {
    return story(queue, new ListMemory());
  }

  @NotNull
  public <T> StoryNarrator<T> story(@NotNull final BlockingQueue<Object> queue,
      @NotNull final Memory memory) {
    SettingInfo.set(settingInfo);
    try {
      return new StoryNarrator<T>(queue, memory);

    } finally {
      SettingInfo.unset();
    }
  }

  @NotNull
  public <T> StoryNarrator<T> story(@NotNull final Memory memory) {
    return story(new LinkedBlockingQueue<Object>(), memory);
  }

  @NotNull
  public <T> Story<T> story(
      @NotNull final NullaryFunction<? extends Story<? extends T>> storyCreator) {
    return story(storyCreator, new ListMemory());
  }

  @NotNull
  public <T> Story<T> story(
      @NotNull final NullaryFunction<? extends Story<? extends T>> storyCreator,
      @NotNull final Memory memory) {
    final Actor actor = this.actor;
    SettingInfo.set(settingInfo);
    try {
      final ActorStory<T> story = new ActorStory<T>(actor, memory);
      actor.tell(new CreateNullaryStory(storyCreator), Headers.empty(), story.getActor());
      return story;

    } finally {
      SettingInfo.unset();
    }
  }

  @NotNull
  public <T, R> Story<R> story(@NotNull final Iterable<? extends Story<? extends T>> stories,
      @NotNull final UnaryFunction<? super List<? extends Story<? extends T>>, ? extends Story<? extends R>> storyCreator) {
    return story(stories, storyCreator, new ListMemory());
  }

  @NotNull
  public <T, R> Story<R> story(@NotNull final Iterable<? extends Story<? extends T>> stories,
      @NotNull final UnaryFunction<? super List<? extends Story<? extends T>>, ? extends Story<? extends R>> storyCreator,
      @NotNull final Memory memory) {
    final Actor actor = this.actor;
    SettingInfo.set(settingInfo);
    try {
      final ActorStory<R> story = new ActorStory<R>(actor, memory);
      final Headers headers = Headers.empty().withThreadId(story.getActor().getId());
      for (final Story<? extends T> aStory : stories) {
        actor.tell(PlotSignal.CREATE_PARAM, headers, aStory.getActor());
      }
      actor.tell(new CreateStory<T>(storyCreator), headers, story.getActor());
      return story;

    } finally {
      SettingInfo.unset();
    }
  }
{{#arities}}

  @NotNull
  public <{{#paramTypes}}{{type}} extends Story<?>, {{/paramTypes}}R> Story<R> story({{#paramTypes}}@NotNull final {{type}} {{prefix}}Story, {{/paramTypes}}
      @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Story<? extends R>> storyCreator) {
      return story({{#paramTypes}}{{prefix}}Story, {{/paramTypes}}storyCreator, new ListMemory());
  }

  @NotNull
  public <{{#paramTypes}}{{type}} extends Story<?>, {{/paramTypes}}R> Story<R> story({{#paramTypes}}@NotNull final {{type}} {{prefix}}Story, {{/paramTypes}}
      @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Story<? extends R>> storyCreator,
      @NotNull final Memory memory) {
    final Actor actor = this.actor;
    SettingInfo.set(settingInfo);
    try {
      final ActorStory<R> story = new ActorStory<R>(actor, memory);
      final Headers headers = Headers.empty().withThreadId(story.getActor().getId());
{{#paramTypes}}      actor.tell(PlotSignal.CREATE_PARAM, headers, {{prefix}}Story.getActor());
{{/paramTypes}}
      actor.tell(new Create{{classPrefix}}Story<{{#paramTypes}}{{type}}{{#hasNext}}, {{/hasNext}}{{/paramTypes}}>(storyCreator), headers, story.getActor());
      return story;

    } finally {
      SettingInfo.unset();
    }
  }
{{/arities}}

  private static class ActorParam {

    private final ArrayList<Actor> actors = new ArrayList<Actor>();

    private long timeoutMillis;
  }

  private static class CreateEvent<T> implements Serializable {

    private static final long serialVersionUID = BuildConfig.SERIAL_VERSION_UID;

    private final UnaryFunction<? super List<? extends Event<? extends T>>, ? extends Event<?>> creator;

    private CreateEvent() {
      creator = null;
    }

    private CreateEvent(@NotNull final UnaryFunction<? super List<? extends Event<? extends T>>, ? extends Event<?>> creator) {
      this.creator = ConstantConditions.notNull("creator", creator);
    }

    public UnaryFunction<? super List<? extends Event<? extends T>>, ? extends Event<?>> getCreator() {
      return creator;
    }
  }

  private static class CreateNullaryEvent implements Serializable {

    private static final long serialVersionUID = BuildConfig.SERIAL_VERSION_UID;

    private final NullaryFunction<? extends Event<?>> creator;

    private CreateNullaryEvent() {
      creator = null;
    }

    private CreateNullaryEvent(@NotNull final NullaryFunction<? extends Event<?>> creator) {
      this.creator = ConstantConditions.notNull("creator", creator);
    }

    public NullaryFunction<? extends Event<?>> getCreator() {
      return creator;
    }
  }

  private static class CreateNullaryStory implements Serializable {

    private static final long serialVersionUID = BuildConfig.SERIAL_VERSION_UID;

    private final NullaryFunction<? extends Story<?>> creator;

    private CreateNullaryStory() {
      creator = null;
    }

    private CreateNullaryStory(@NotNull final NullaryFunction<? extends Story<?>> creator) {
      this.creator = ConstantConditions.notNull("creator", creator);
    }

    public NullaryFunction<? extends Story<?>> getCreator() {
      return creator;
    }
  }

  private static class CreateStory<T> implements Serializable {

    private static final long serialVersionUID = BuildConfig.SERIAL_VERSION_UID;

    private final UnaryFunction<? super List<? extends Story<? extends T>>, ? extends Story<?>> creator;

    private CreateStory() {
      creator = null;
    }

    private CreateStory(@NotNull final UnaryFunction<? super List<? extends Story<? extends T>>, ? extends Story<?>> creator) {
      this.creator = ConstantConditions.notNull("creator", creator);
    }

    public UnaryFunction<? super List<? extends Story<? extends T>>, ? extends Story<?>> getCreator() {
      return creator;
    }
  }
{{#arities}}

  private static class Create{{classPrefix}}Event<{{#paramTypes}}{{type}} extends Event<?>{{#hasNext}}, {{/hasNext}}{{/paramTypes}}>
      implements Serializable {

    private static final long serialVersionUID = BuildConfig.SERIAL_VERSION_UID;

    private final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Event<?>> creator;

    private Create{{classPrefix}}Event() {
      creator = null;
    }

    private Create{{classPrefix}}Event(
        @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Event<?>> creator) {
      this.creator = ConstantConditions.notNull("creator", creator);
    }

    public {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Event<?>> getCreator() {
      return creator;
    }
  }

  private static class Create{{classPrefix}}Story<{{#paramTypes}}{{type}} extends Story<?>{{#hasNext}}, {{/hasNext}}{{/paramTypes}}>
      implements Serializable {

    private static final long serialVersionUID = BuildConfig.SERIAL_VERSION_UID;

    private final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Story<?>> creator;

    private Create{{classPrefix}}Story() {
      creator = null;
    }

    private Create{{classPrefix}}Story(
        @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Story<?>> creator) {
      this.creator = ConstantConditions.notNull("creator", creator);
    }

    public {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Story<?>> getCreator() {
      return creator;
    }
  }
{{/arities}}

  private static class DefaultSetting extends SerializableSetting {

    private static final long serialVersionUID = BuildConfig.SERIAL_VERSION_UID;

    private Object readResolve() throws ObjectStreamException {
      return DEFAULT_SETTING;
    }
  }

  private static class EventWrapper<T> extends Event<T> {

    private final Actor actor;

    private EventWrapper(@NotNull final Actor actor) {
      this.actor = actor;
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class PlotFactoryBehavior extends AbstractBehavior {

    private static final long EXPIRATION_MILLIS = TimeUnit.MINUTES.toMillis(15);

    private final WeakValueHashMap<Actor, Actor> actors = new WeakValueHashMap<Actor, Actor>();
    private final HashMap<Class<?>, Handler<Object>> handlers =
        new HashMap<Class<?>, Handler<Object>>() { {
          put(CreateEvent.class, new Handler<Object>() {

            @SuppressWarnings("unchecked")
            public void handle(final Object message, @NotNull final Envelop envelop,
                @NotNull final Agent agent) {
              Actor actor;
              SettingInfo.set(settingInfo);
              try {
                final String threadId = envelop.getHeaders().getThreadId();
                final ArrayList<Actor> actorParams = params.remove(threadId).actors;
                final ArrayList<Event<?>> events = new ArrayList<Event<?>>();
                for (final Actor actorParam : actorParams) {
                  events.add(new EventWrapper<Object>(actorParam));
                }
                actor = ((CreateEvent<Object>) message).getCreator().call(events).getActor();

              } catch (final Exception e) {
                actor = Event.ofIncident(e).getActor();

              } finally {
                SettingInfo.unset();
              }
              final Actor sender = envelop.getSender();
              senders.put(sender, actor);
              actors.put(actor, sender);
            }
          });
          put(CreateNullaryEvent.class, new Handler<Object>() {

            public void handle(final Object message, @NotNull final Envelop envelop,
                @NotNull final Agent agent) {
              Actor actor;
              SettingInfo.set(settingInfo);
              try {
                actor = ((CreateNullaryEvent) message).getCreator().call().getActor();

              } catch (final Exception e) {
                actor = Event.ofIncident(e).getActor();

              } finally {
                SettingInfo.unset();
              }
              final Actor sender = envelop.getSender();
              senders.put(sender, actor);
              actors.put(actor, sender);
            }
          });
          put(CreateNullaryStory.class, new Handler<Object>() {

            public void handle(final Object message, @NotNull final Envelop envelop,
                @NotNull final Agent agent) {
              Actor actor;
              SettingInfo.set(settingInfo);
              try {
                actor = ((CreateNullaryStory) message).getCreator().call().getActor();

              } catch (final Exception e) {
                actor = Story.ofSingleIncident(e).getActor();

              } finally {
                SettingInfo.unset();
              }
              final Actor sender = envelop.getSender();
              senders.put(sender, actor);
              actors.put(actor, sender);
            }
          });
          put(CreateStory.class, new Handler<Object>() {

            @SuppressWarnings("unchecked")
            public void handle(final Object message, @NotNull final Envelop envelop,
                @NotNull final Agent agent) {
              Actor actor;
              SettingInfo.set(settingInfo);
              try {
                final String threadId = envelop.getHeaders().getThreadId();
                final ArrayList<Actor> actorParams = params.remove(threadId).actors;
                final ArrayList<Story<?>> stories = new ArrayList<Story<?>>();
                for (final Actor actorParam : actorParams) {
                  stories.add(new StoryWrapper<Object>(actorParam));
                }
                actor = ((CreateStory<Object>) message).getCreator().call(stories).getActor();

              } catch (final Exception e) {
                actor = Story.ofSingleIncident(e).getActor();

              } finally {
                SettingInfo.unset();
              }
              final Actor sender = envelop.getSender();
              senders.put(sender, actor);
              actors.put(actor, sender);
            }
          });
{{#arities}}
          put(Create{{classPrefix}}Event.class, new Handler<Object>() {

            @SuppressWarnings("unchecked")
            public void handle(final Object message, @NotNull final Envelop envelop,
                @NotNull final Agent agent) {
              Actor actor;
              SettingInfo.set(settingInfo);
              try {
                final String threadId = envelop.getHeaders().getThreadId();
                final ArrayList<Actor> actorParams = params.remove(threadId).actors;
                if (actorParams.size() != {{paramNum}}) {
                  actor = Event.ofIncident(new IllegalStateException()).getActor();

                } else {
{{#paramTypes}}                  final EventWrapper<Object> {{prefix}}Event = new EventWrapper<Object>(actorParams.get({{index}}));
{{/paramTypes}}
                  actor = ((Create{{classPrefix}}Event<{{#paramTypes}}Event<?>{{#hasNext}}, {{/hasNext}}{{/paramTypes}}>) message).getCreator().call({{#paramTypes}}{{prefix}}Event{{#hasNext}}, {{/hasNext}}{{/paramTypes}}).getActor();
                }

              } catch (final Exception e) {
                actor = Event.ofIncident(e).getActor();

              } finally {
                SettingInfo.unset();
              }
              final Actor sender = envelop.getSender();
              senders.put(sender, actor);
              actors.put(actor, sender);
            }
          });
          put(Create{{classPrefix}}Story.class, new Handler<Object>() {

            @SuppressWarnings("unchecked")
            public void handle(final Object message, @NotNull final Envelop envelop,
                @NotNull final Agent agent) {
              Actor actor;
              SettingInfo.set(settingInfo);
              try {
                final String threadId = envelop.getHeaders().getThreadId();
                final ArrayList<Actor> actorParams = params.remove(threadId).actors;
                if (actorParams.size() != {{paramNum}}) {
                  actor = Story.ofSingleIncident(new IllegalStateException()).getActor();

                } else {
{{#paramTypes}}                  final StoryWrapper<Object> {{prefix}}Story = new StoryWrapper<Object>(actorParams.get({{index}}));
{{/paramTypes}}
                  actor = ((Create{{classPrefix}}Story<{{#paramTypes}}Story<?>{{#hasNext}}, {{/hasNext}}{{/paramTypes}}>) message).getCreator().call({{#paramTypes}}{{prefix}}Story{{#hasNext}}, {{/hasNext}}{{/paramTypes}}).getActor();
                }

              } catch (final Exception e) {
                actor = Story.ofSingleIncident(e).getActor();

              } finally {
                SettingInfo.unset();
              }
              final Actor sender = envelop.getSender();
              senders.put(sender, actor);
              actors.put(actor, sender);
            }
          });
{{/arities}}
        } };
    private final HashMap<String, ActorParam> params = new HashMap<String, ActorParam>();
    private final WeakHashMap<Actor, Actor> senders = new WeakHashMap<Actor, Actor>();
    private final SettingInfo settingInfo;

    private PlotFactoryBehavior(@NotNull final SettingInfo settingInfo) {
      this.settingInfo = settingInfo;
    }

    public void onMessage(final Object message, @NotNull final Envelop envelop,
        @NotNull final Agent agent) throws Exception {
      if (message != null) {
        final Handler<Object> handler = handlers.get(message.getClass());
        if (handler != null) {
          handler.handle(message, envelop, agent);
          envelop.preventReceipt();
          return;
        }
      }

      if (message == PlotSignal.CREATE_PARAM) {
        final String threadId = envelop.getHeaders().getThreadId();
        final HashMap<String, ActorParam> params = this.params;
        ActorParam param = params.get(threadId);
        if (param == null) {
          param = new ActorParam();
          params.put(threadId, param);
        }
        final long now = System.currentTimeMillis();
        param.actors.add(envelop.getSender());
        param.timeoutMillis = now + EXPIRATION_MILLIS;
        final Iterator<ActorParam> iterator = params.values().iterator();
        while (iterator.hasNext()) {
          if (iterator.next().timeoutMillis < now) {
            iterator.remove();
          }
        }

      } else {
        final Actor sender = envelop.getSender();
        Actor actor = senders.get(sender);
        if (actor == null) {
          actor = actors.get(sender);
        }

        if (actor != null) {
          actor.tell(message, envelop.getHeaders().asSentAt(envelop.getSentAt()),
              agent.getSelf());

        } else {
          sender.tell(new Bounce(), envelop.getHeaders().threadOnly(), agent.getSelf());
        }
        envelop.preventReceipt();
      }
    }
  }

  private static class PlotFactoryRole extends SerializableRole {

    private static final long serialVersionUID = BuildConfig.SERIAL_VERSION_UID;

    private final Setting setting;

    private transient SettingInfo settingInfo;

    private PlotFactoryRole() {
      this(DEFAULT_SETTING);
    }

    private PlotFactoryRole(@NotNull final Setting setting) {
      this.setting = ConstantConditions.notNull("setting", setting);
    }

    @NotNull
    @Override
    public ExecutorService getExecutorService(@NotNull final String id) throws Exception {
      return getSettingInfo(id).getExecutor();
    }

    @NotNull
    @Override
    public Logger getLogger(@NotNull final String id) throws Exception {
      return getSettingInfo(id).getLogger();
    }

    @NotNull
    public Setting getSetting() {
      return setting;
    }

    @NotNull
    protected Behavior getSerializableBehavior(@NotNull final String id) throws Exception {
      return new PlotFactoryBehavior(getSettingInfo(id));
    }

    @NotNull
    private SettingInfo getSettingInfo(@NotNull final String id) throws Exception {
      if (settingInfo == null) {
        final Setting setting = this.setting;
        settingInfo = new SettingInfo(setting.getExecutorService(id), setting.getLogger(id));
      }
      return settingInfo;
    }
  }

  private enum PlotSignal {
    CREATE_PARAM
  }

  private static class StoryWrapper<T> extends Story<T> {

    private final Actor actor;

    private StoryWrapper(@NotNull final Actor actor) {
      this.actor = actor;
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }
}
