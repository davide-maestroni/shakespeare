/*
 * Copyright 2019 Davide Maestroni
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dm.shakespeare.plot;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.InputStream;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import dm.shakespeare.Stage;
import dm.shakespeare.actor.AbstractBehavior;
import dm.shakespeare.actor.Actor;
import dm.shakespeare.actor.Behavior;
import dm.shakespeare.actor.Behavior.Agent;
import dm.shakespeare.actor.Envelop;
import dm.shakespeare.actor.Headers;
import dm.shakespeare.actor.Role;
import dm.shakespeare.concurrent.ExecutorServices;
import dm.shakespeare.function.Observer;
import dm.shakespeare.message.Bounce;
import dm.shakespeare.message.Receipt;
import dm.shakespeare.plot.Setting.Cache;
import dm.shakespeare.plot.function.Action;
import dm.shakespeare.plot.function.NullaryFunction;
{{#arities}}
import dm.shakespeare.plot.function.{{classPrefix}}Function;
{{/arities}}
import dm.shakespeare.plot.memory.ListMemory;
import dm.shakespeare.plot.memory.Memory;
import dm.shakespeare.plot.memory.SingletonMemory;
import dm.shakespeare.plot.narrator.Narrator;
import dm.shakespeare.util.ConstantConditions;
import dm.shakespeare.util.Iterables;

/**
 * Created by davide-maestroni on 01/22/2019.
 */
public abstract class Story<T> extends Event<Iterable<T>> {

  static final Object BREAK = new Object();
  static final Object END = new Object();
  static final Object NEXT = new Object();

  private static final NullaryFunction<? extends ByteBuffer> DEFAULT_BUFFER_CREATOR =
      new NullaryFunction<ByteBuffer>() {

        public ByteBuffer call() {
          return ByteBuffer.allocate(8 << 10);
        }
      };
  private static final NullaryFunction<Event<Boolean>> INFINITE_LOOP =
      new NullaryFunction<Event<Boolean>>() {

        public Event<Boolean> call() {
          return Event.ofTrue();
        }
      };
  private static final Action NO_OP = new Action() {

    public void run() {
    }
  };

  @NotNull
  public static <T> Story<T> ofEffects(@NotNull final Iterable<? extends T> effects) {
    final Cache cache = Setting.get().getCache(Story.class);
    Story<T> story = cache.get(effects);
    if (story == null) {
      story = new EffectsStory<T>(effects);
      cache.put(effects, story);
    }
    return story;
  }

  @NotNull
  public static <T> Story<T> ofEffects(@NotNull final NullaryFunction<? extends T> effectsCreator) {
    return ofEffects(new CreatorIterable<T>(effectsCreator));
  }

  @NotNull
  public static <T> Story<T> ofEmpty() {
    return ofEffects(Collections.<T>emptyList());
  }

  @NotNull
  public static <T> Story<T> ofIncidents(@NotNull final Iterable<? extends Throwable> incidents) {
    return new IncidentsStory<T>(incidents);
  }

  @NotNull
  public static <T> Story<T> ofIncidents(
      @NotNull final NullaryFunction<? extends Throwable> incidentsCreator) {
    return ofIncidents(new CreatorIterable<Throwable>(incidentsCreator));
  }

  @NotNull
  public static Story<ByteBuffer> ofInputStream(@NotNull final InputStream inputStream) {
    return ofInputStream(inputStream, DEFAULT_BUFFER_CREATOR, new ListMemory());
  }

  @NotNull
  public static Story<ByteBuffer> ofInputStream(@NotNull final InputStream inputStream,
      @NotNull final Memory memory) {
    return ofInputStream(inputStream, DEFAULT_BUFFER_CREATOR, memory);
  }

  @NotNull
  public static Story<ByteBuffer> ofInputStream(@NotNull final InputStream inputStream,
      @NotNull final NullaryFunction<? extends ByteBuffer> bufferCreator) {
    return ofInputStream(inputStream, bufferCreator, new ListMemory());
  }

  @NotNull
  public static Story<ByteBuffer> ofInputStream(@NotNull final InputStream inputStream,
      @NotNull final NullaryFunction<? extends ByteBuffer> bufferCreator,
      @NotNull final Memory memory) {
    return new EffectsStory<ByteBuffer>(
        new InputStreamIterable(inputStream, bufferCreator, memory));
  }

  @NotNull
  public static <T> StoryNarrator<T> ofNarrations() {
    return ofNarrations(new LinkedBlockingQueue<Object>());
  }

  @NotNull
  public static <T> StoryNarrator<T> ofNarrations(@NotNull final BlockingQueue<Object> queue) {
    return ofNarrations(queue, new ListMemory());
  }

  @NotNull
  public static <T> StoryNarrator<T> ofNarrations(@NotNull final BlockingQueue<Object> queue,
      @NotNull final Memory memory) {
    return new StoryNarrator<T>(queue, memory);
  }

  @NotNull
  public static <T> StoryNarrator<T> ofNarrations(@NotNull final Memory memory) {
    return ofNarrations(new LinkedBlockingQueue<Object>(), memory);
  }

  @NotNull
  public static <T> Story<T> ofSingleEffect(final T effect) {
    final Cache cache = Setting.get().getCache(Story.class);
    Story<T> story = cache.get(effect);
    if (story == null) {
      story = new EffectStory<T>(effect);
      cache.put(effect, story);
    }
    return story;
  }

  @NotNull
  public static <T> Story<T> ofSingleEvent(@NotNull final Event<? extends T> event) {
    return new EventStory<T>(event);
  }

  @NotNull
  public static <T> Story<T> ofSingleIncident(@NotNull final Throwable incident) {
    return new IncidentStory<T>(incident);
  }

  @NotNull
  public static <T> Story<T> ofStory(
      @NotNull final NullaryFunction<? extends Story<? extends T>> storyCreator) {
    return ofStory(storyCreator, new ListMemory());
  }

  @NotNull
  public static <T> Story<T> ofStory(
      @NotNull final NullaryFunction<? extends Story<? extends T>> storyCreator,
      @NotNull final Memory memory) {
    return new FunctionStory<T>(storyCreator, memory);
  }

  @NotNull
  @SuppressWarnings("unchecked")
  public static <T> Story<T> unfold(@NotNull final Event<? extends Iterable<? extends T>> event) {
    if (event instanceof Story) {
      return (Story<T>) event;
    }
    return new UnfoldStory<T>(event);
  }

  @NotNull
  public static <T, R> Story<R> when(@NotNull final Iterable<? extends Story<? extends T>> stories,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super List<T>, ? extends Story<? extends R>> effectHandler) {
    return when(stories, conditionHandler, effectHandler, new ListMemory());
  }

  @NotNull
  public static <T, R> Story<R> when(@NotNull final Iterable<? extends Story<? extends T>> stories,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super List<T>, ? extends Story<? extends R>> effectHandler,
      @NotNull final Memory memory) {
    return new GenericStory<T, R>(stories, conditionHandler, effectHandler, memory);
  }

  @NotNull
  public static <T, R> Story<R> when(@NotNull final Iterable<? extends Story<? extends T>> stories,
      @NotNull final StoryEvolver<? super List<T>, ? extends R> storyEvolver) {
    return when(stories, storyEvolver, new ListMemory());
  }

  @NotNull
  public static <T, R> Story<R> when(@NotNull final Iterable<? extends Story<? extends T>> stories,
      @NotNull final StoryEvolver<? super List<T>, ? extends R> storyEvolver,
      @NotNull final Memory memory) {
    return when(stories, new EvolverConditionHandler(storyEvolver),
        new EvolverEffectHandler<List<T>, R>(storyEvolver), memory);
  }
{{#arities}}

  @NotNull
  public static <{{#paramTypes}}{{type}}, {{/paramTypes}}R> Story<R> when({{#paramTypes}}@NotNull final Story<? extends {{type}}> {{prefix}}Story, {{/paramTypes}}
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Story<? extends R>> effectHandler) {
    return when({{#paramTypes}}{{prefix}}Story, {{/paramTypes}}conditionHandler, effectHandler, new ListMemory());
  }

  @NotNull
  public static <{{#paramTypes}}{{type}}, {{/paramTypes}}R> Story<R> when({{#paramTypes}}@NotNull final Story<? extends {{type}}> {{prefix}}Story, {{/paramTypes}}
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Story<? extends R>> effectHandler,
      @NotNull final Memory memory) {
    return new {{classPrefix}}Story<{{#paramTypes}}{{type}}, {{/paramTypes}}R>({{#paramTypes}}{{prefix}}Story, {{/paramTypes}}conditionHandler, effectHandler, memory);
  }
{{/arities}}

  @NotNull
  public static <T, R> Story<R> whenTransform(
      @NotNull final Iterable<? extends Story<? extends T>> stories,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super List<T>, ? extends R> effectHandler) {
    return whenTransform(stories, conditionHandler, effectHandler, new ListMemory());
  }

  @NotNull
  public static <T, R> Story<R> whenTransform(
      @NotNull final Iterable<? extends Story<? extends T>> stories,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super List<T>, ? extends R> effectHandler,
      @NotNull final Memory memory) {
    return new GenericTransformStory<T, R>(stories, conditionHandler, effectHandler, memory);
  }

  @NotNull
  public static <T, R> Story<R> whenTransform(
      @NotNull final Iterable<? extends Story<? extends T>> stories,
      @NotNull final StoryTransformer<? super List<T>, ? extends R> storyTransformer) {
    return whenTransform(stories, storyTransformer, new ListMemory());
  }

  @NotNull
  public static <T, R> Story<R> whenTransform(
      @NotNull final Iterable<? extends Story<? extends T>> stories,
      @NotNull final StoryTransformer<? super List<T>, ? extends R> storyTransformer,
      @NotNull final Memory memory) {
    return whenTransform(stories, new TransformerConditionHandler(storyTransformer),
        new TransformerEffectHandler<List<T>, R>(storyTransformer), memory);
  }
{{#arities}}

  @NotNull
  public static <{{#paramTypes}}{{type}}, {{/paramTypes}}R> Story<R> whenTransform({{#paramTypes}}@NotNull final Story<? extends {{type}}> {{prefix}}Story, {{/paramTypes}}
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends R> effectHandler) {
    return whenTransform({{#paramTypes}}{{prefix}}Story, {{/paramTypes}}conditionHandler, effectHandler, new ListMemory());
  }

  @NotNull
  public static <{{#paramTypes}}{{type}}, {{/paramTypes}}R> Story<R> whenTransform({{#paramTypes}}@NotNull final Story<? extends {{type}}> {{prefix}}Story, {{/paramTypes}}
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends R> effectHandler,
      @NotNull final Memory memory) {
    return new {{classPrefix}}TransformStory<{{#paramTypes}}{{type}}, {{/paramTypes}}R>({{#paramTypes}}{{prefix}}Story, {{/paramTypes}}conditionHandler, effectHandler, memory);
  }
{{/arities}}

  static void done(@NotNull final Memory memory, @NotNull final Map<String, Sender> getSenders,
      @NotNull final Map<String, SenderIterator> nextSenders, @NotNull final Agent agent) {
    Object effects = memory;
    for (final Object effect : memory) {
      if (effect instanceof Conflict) {
        effects = effect;
        break;
      }
    }
    final Actor self = agent.getSelf();
    for (final Sender sender : getSenders.values()) {
      sender.getSender().tell(effects, sender.getHeaders(), self);
    }
    for (final SenderIterator sender : nextSenders.values()) {
      if (sender.isWaitNext() && !sender.tellNext(self)) {
        sender.getSender().tell(END, sender.getHeaders(), self);
      }
    }
    agent.setBehavior(new DoneBehavior(effects, memory, nextSenders));
  }

  static void fail(@NotNull final Conflict conflict, @NotNull final Memory memory,
      @NotNull final Map<String, Sender> getSenders,
      @NotNull final Map<String, SenderIterator> nextSenders, @NotNull final Agent agent) {
    final Actor self = agent.getSelf();
    for (final Sender sender : getSenders.values()) {
      sender.getSender().tell(conflict, sender.getHeaders(), self);
    }
    memory.put(conflict);
    for (final SenderIterator sender : nextSenders.values()) {
      sender.tellNext(self);
    }
    agent.setBehavior(new DoneBehavior(conflict, memory, nextSenders));
  }

  private static boolean isEmpty(@Nullable final Story<?> story) {
    final Cache cache = Setting.get().getCache(Story.class);
    return (cache.get(Collections.EMPTY_LIST) == story) || (cache.get(Collections.EMPTY_SET)
        == story);
  }

  private static boolean isSame(@Nullable final Object expected, @Nullable final Object actual) {
    return (expected == actual) || (expected != null) && expected.equals(actual);
  }

  @NotNull
  public <R> Story<R> blend(final int maxConcurrency,
      @NotNull final UnaryFunction<? super T, ? extends Story<? extends R>> effectHandler) {
    return blend(maxConcurrency, effectHandler, new ListMemory());
  }

  @NotNull
  public <R> Story<R> blend(final int maxConcurrency,
      @NotNull final UnaryFunction<? super T, ? extends Story<? extends R>> effectHandler,
      @NotNull final Memory memory) {
    return new BlendStory<T, R>(this, maxConcurrency, effectHandler, memory);
  }

  @NotNull
  @Override
  public Story<T> eventually(@NotNull final Action eventualAction) {
    return eventually(eventualAction, new ListMemory());
  }

  @NotNull
  public Story<T> eventually(@NotNull final Action eventualAction, @NotNull final Memory memory) {
    return new EventualStory<T>(this, eventualAction, memory);
  }

  @NotNull
  public <R> Story<R> forAll(
      @NotNull final UnaryFunction<? super T, ? extends Story<? extends R>> effectHandler) {
    return forAll(effectHandler, new ListMemory());
  }

  @NotNull
  public <R> Story<R> forAll(
      @NotNull final UnaryFunction<? super T, ? extends Story<? extends R>> effectHandler,
      @NotNull final Memory memory) {
    return new AllStory<T, R>(this, effectHandler, memory);
  }

  @NotNull
  public <R> Story<R> forAllTransform(
      @NotNull final UnaryFunction<? super T, ? extends R> effectHandler) {
    return forAllTransform(effectHandler, new ListMemory());
  }

  @NotNull
  public <R> Story<R> forAllTransform(
      @NotNull final UnaryFunction<? super T, ? extends R> effectHandler,
      @NotNull final Memory memory) {
    return new AllTransformStory<T, R>(this, effectHandler, memory);
  }

  @NotNull
  public Story<T> forWhile(
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler) {
    return forWhile(conditionHandler, new ListMemory());
  }

  @NotNull
  public Story<T> forWhile(
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final Memory memory) {
    return new NullaryStory<T>(this, conditionHandler, memory);
  }

  @NotNull
  public <R> Story<R> forWhile(
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super T, ? extends Story<? extends R>> effectHandler) {
    return when(this, conditionHandler, effectHandler);
  }

  @NotNull
  public <R> Story<R> forWhile(
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super T, ? extends Story<? extends R>> effectHandler,
      @NotNull final Memory memory) {
    return when(this, conditionHandler, effectHandler, memory);
  }

  @NotNull
  public <R> Story<R> forWhile(@NotNull final StoryEvolver<? super T, ? extends R> storyEvolver) {
    return forWhile(storyEvolver, new ListMemory());
  }

  @NotNull
  public <R> Story<R> forWhile(@NotNull final StoryEvolver<? super T, ? extends R> storyEvolver,
      @NotNull final Memory memory) {
    return forWhile(new EvolverConditionHandler(storyEvolver),
        new EvolverEffectHandler<T, R>(storyEvolver), memory);
  }

  @NotNull
  public <R> Story<R> forWhileTransform(
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super T, ? extends R> effectHandler) {
    return whenTransform(this, conditionHandler, effectHandler);
  }

  @NotNull
  public <R> Story<R> forWhileTransform(
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super T, ? extends R> effectHandler,
      @NotNull final Memory memory) {
    return whenTransform(this, conditionHandler, effectHandler, memory);
  }

  @NotNull
  public <R> Story<R> forWhileTransform(
      @NotNull final StoryTransformer<? super T, ? extends R> storyTransformer) {
    return forWhileTransform(storyTransformer, new ListMemory());
  }

  @NotNull
  public <R> Story<R> forWhileTransform(
      @NotNull final StoryTransformer<? super T, ? extends R> storyTransformer,
      @NotNull final Memory memory) {
    return forWhileTransform(new TransformerConditionHandler(storyTransformer),
        new TransformerEffectHandler<T, R>(storyTransformer), memory);
  }

  @NotNull
  public <R> Story<R> join(final int maxConcurrency, final int maxEventWindow,
      @NotNull final UnaryFunction<? super T, ? extends Event<? extends R>> effectHandler) {
    return join(maxConcurrency, maxEventWindow, effectHandler, new ListMemory());
  }

  @NotNull
  public <R> Story<R> join(final int maxConcurrency, final int maxEventWindow,
      @NotNull final UnaryFunction<? super T, ? extends Event<? extends R>> effectHandler,
      @NotNull final Memory memory) {
    return new JoinStory<T, R>(this, maxConcurrency, maxEventWindow, effectHandler, memory);
  }

  @NotNull
  public Spectator playEach(@NotNull final EventObserver<? super T> eventObserver) {
    return playEach(new EventStoryObserver<T>(eventObserver));
  }

  @NotNull
  public Spectator playEach(@Nullable final Observer<? super T> effectObserver,
      @Nullable final Observer<? super Throwable> incidentObserver,
      @Nullable final Action endAction) {
    return playEach(new DefaultStoryObserver<T>(effectObserver, incidentObserver, endAction));
  }

  @NotNull
  public Spectator playEach(@NotNull final StoryObserver<? super T> storyObserver) {
    final Actor actor = Stage.newActor(new StoryObserverRole<T>(getActor(), storyObserver));
    final String actorId = actor.getId();
    getActor().tell(NEXT, new Headers().withReceiptId(actorId).withThreadId(actorId), actor);
    return new Spectator(actor);
  }

  @NotNull
  public <E1 extends Throwable, E2 extends Throwable, E3 extends Throwable> Story<T> resolveWhile(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final Class<? extends E3> thirdType,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends Story<? extends T>> incidentHandler) {
    return resolveWhile(firstType, secondType, thirdType, conditionHandler, incidentHandler,
        new ListMemory());
  }

  @NotNull
  @SuppressWarnings("unchecked")
  public <E1 extends Throwable, E2 extends Throwable, E3 extends Throwable> Story<T> resolveWhile(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final Class<? extends E3> thirdType,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends Story<? extends T>> incidentHandler,
      @NotNull final Memory memory) {
    final HashSet<Class<? extends Throwable>> types = new HashSet<Class<? extends Throwable>>();
    types.add(firstType);
    types.add(secondType);
    types.add(thirdType);
    return new ResolveStory<T>(this, types, conditionHandler,
        (UnaryFunction<? super Throwable, ? extends Story<T>>) incidentHandler, memory);
  }

  @NotNull
  public <E1 extends Throwable, E2 extends Throwable, E3 extends Throwable> Story<T> resolveWhile(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final Class<? extends E3> thirdType,
      @NotNull final StoryEvolver<? super Throwable, ? extends T> storyEvolver) {
    return resolveWhile(firstType, secondType, thirdType, storyEvolver, new ListMemory());
  }

  @NotNull
  public <E1 extends Throwable, E2 extends Throwable, E3 extends Throwable> Story<T> resolveWhile(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final Class<? extends E3> thirdType,
      @NotNull final StoryEvolver<? super Throwable, ? extends T> storyEvolver,
      @NotNull final Memory memory) {
    return resolveWhile(firstType, secondType, thirdType, new EvolverConditionHandler(storyEvolver),
        new EvolverEffectHandler<Throwable, T>(storyEvolver), memory);
  }

  @NotNull
  public <E1 extends Throwable, E2 extends Throwable> Story<T> resolveWhile(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends Story<? extends T>> incidentHandler) {
    return resolveWhile(firstType, secondType, conditionHandler, incidentHandler, new ListMemory());
  }

  @NotNull
  @SuppressWarnings("unchecked")
  public <E1 extends Throwable, E2 extends Throwable> Story<T> resolveWhile(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends Story<? extends T>> incidentHandler,
      @NotNull final Memory memory) {
    final HashSet<Class<? extends Throwable>> types = new HashSet<Class<? extends Throwable>>();
    types.add(firstType);
    types.add(secondType);
    return new ResolveStory<T>(this, types, conditionHandler,
        (UnaryFunction<? super Throwable, ? extends Story<T>>) incidentHandler, memory);
  }

  @NotNull
  public <E1 extends Throwable, E2 extends Throwable> Story<T> resolveWhile(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final StoryEvolver<? super Throwable, ? extends T> storyEvolver) {
    return resolveWhile(firstType, secondType, storyEvolver, new ListMemory());
  }

  @NotNull
  public <E1 extends Throwable, E2 extends Throwable> Story<T> resolveWhile(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final StoryEvolver<? super Throwable, ? extends T> storyEvolver,
      @NotNull final Memory memory) {
    return resolveWhile(firstType, secondType, new EvolverConditionHandler(storyEvolver),
        new EvolverEffectHandler<Throwable, T>(storyEvolver), memory);
  }

  @NotNull
  public <E1 extends Throwable> Story<T> resolveWhile(@NotNull final Class<? extends E1> firstType,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends Story<? extends T>> incidentHandler) {
    return resolveWhile(firstType, conditionHandler, incidentHandler, new ListMemory());
  }

  @NotNull
  @SuppressWarnings("unchecked")
  public <E1 extends Throwable> Story<T> resolveWhile(@NotNull final Class<? extends E1> firstType,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends Story<? extends T>> incidentHandler,
      @NotNull final Memory memory) {
    final Set<Class<? extends Throwable>> types =
        Collections.<Class<? extends Throwable>>singleton(firstType);
    return new ResolveStory<T>(this, types, conditionHandler,
        (UnaryFunction<? super Throwable, ? extends Story<T>>) incidentHandler, memory);
  }

  @NotNull
  public <E1 extends Throwable> Story<T> resolveWhile(@NotNull final Class<? extends E1> firstType,
      @NotNull final StoryEvolver<? super Throwable, ? extends T> storyEvolver) {
    return resolveWhile(firstType, storyEvolver, new ListMemory());
  }

  @NotNull
  public <E1 extends Throwable> Story<T> resolveWhile(@NotNull final Class<? extends E1> firstType,
      @NotNull final StoryEvolver<? super Throwable, ? extends T> storyEvolver,
      @NotNull final Memory memory) {
    return resolveWhile(firstType, new EvolverConditionHandler(storyEvolver),
        new EvolverEffectHandler<Throwable, T>(storyEvolver), memory);
  }

  @NotNull
  public <E extends Throwable> Story<T> resolveWhile(
      @NotNull final Iterable<? extends Class<? extends E>> incidentTypes,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends Story<? extends T>> incidentHandler) {
    return resolveWhile(incidentTypes, conditionHandler, incidentHandler, new ListMemory());
  }

  @NotNull
  @SuppressWarnings("unchecked")
  public <E extends Throwable> Story<T> resolveWhile(
      @NotNull final Iterable<? extends Class<? extends E>> incidentTypes,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends Story<? extends T>> incidentHandler,
      @NotNull final Memory memory) {
    return new ResolveStory<T>(this, Iterables.<Class<? extends Throwable>>toSet(incidentTypes),
        conditionHandler, (UnaryFunction<? super Throwable, ? extends Story<T>>) incidentHandler,
        memory);
  }

  @NotNull
  public <E1 extends Throwable, E2 extends Throwable, E3 extends Throwable> Story<T> resolveWhileTransform(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final Class<? extends E3> thirdType,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends T> incidentHandler) {
    return resolveWhileTransform(firstType, secondType, thirdType, conditionHandler,
        incidentHandler, new ListMemory());
  }

  @NotNull
  public <E1 extends Throwable, E2 extends Throwable, E3 extends Throwable> Story<T> resolveWhileTransform(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final Class<? extends E3> thirdType,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends T> incidentHandler,
      @NotNull final Memory memory) {
    final HashSet<Class<? extends Throwable>> types = new HashSet<Class<? extends Throwable>>();
    types.add(firstType);
    types.add(secondType);
    types.add(thirdType);
    return new ResolveTransformStory<T>(this, types, conditionHandler, incidentHandler, memory);
  }

  @NotNull
  public <E1 extends Throwable, E2 extends Throwable, E3 extends Throwable> Story<T> resolveWhileTransform(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final Class<? extends E3> thirdType,
      @NotNull final StoryTransformer<? super Throwable, ? extends T> storyTransformer) {
    return resolveWhileTransform(firstType, secondType, thirdType, storyTransformer,
        new ListMemory());
  }

  @NotNull
  public <E1 extends Throwable, E2 extends Throwable, E3 extends Throwable> Story<T> resolveWhileTransform(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final Class<? extends E3> thirdType,
      @NotNull final StoryTransformer<? super Throwable, ? extends T> storyTransformer,
      @NotNull final Memory memory) {
    return resolveWhileTransform(firstType, secondType, thirdType,
        new TransformerConditionHandler(storyTransformer),
        new TransformerEffectHandler<Throwable, T>(storyTransformer), memory);
  }

  @NotNull
  public <E1 extends Throwable, E2 extends Throwable> Story<T> resolveWhileTransform(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends T> incidentHandler) {
    return resolveWhileTransform(firstType, secondType, conditionHandler, incidentHandler,
        new ListMemory());
  }

  @NotNull
  public <E1 extends Throwable, E2 extends Throwable> Story<T> resolveWhileTransform(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends T> incidentHandler,
      @NotNull final Memory memory) {
    final HashSet<Class<? extends Throwable>> types = new HashSet<Class<? extends Throwable>>();
    types.add(firstType);
    types.add(secondType);
    return new ResolveTransformStory<T>(this, types, conditionHandler, incidentHandler, memory);
  }

  @NotNull
  public <E1 extends Throwable, E2 extends Throwable> Story<T> resolveWhileTransform(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final StoryTransformer<? super Throwable, ? extends T> storyTransformer) {
    return resolveWhileTransform(firstType, secondType, storyTransformer, new ListMemory());
  }

  @NotNull
  public <E1 extends Throwable, E2 extends Throwable> Story<T> resolveWhileTransform(
      @NotNull final Class<? extends E1> firstType, @NotNull final Class<? extends E2> secondType,
      @NotNull final StoryTransformer<? super Throwable, ? extends T> storyTransformer,
      @NotNull final Memory memory) {
    return resolveWhileTransform(firstType, secondType,
        new TransformerConditionHandler(storyTransformer),
        new TransformerEffectHandler<Throwable, T>(storyTransformer), memory);
  }

  @NotNull
  public <E1 extends Throwable> Story<T> resolveWhileTransform(
      @NotNull final Class<? extends E1> firstType,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends T> incidentHandler) {
    return resolveWhileTransform(firstType, conditionHandler, incidentHandler, new ListMemory());
  }

  @NotNull
  public <E1 extends Throwable> Story<T> resolveWhileTransform(
      @NotNull final Class<? extends E1> firstType,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends T> incidentHandler,
      @NotNull final Memory memory) {
    final Set<Class<? extends Throwable>> types =
        Collections.<Class<? extends Throwable>>singleton(firstType);
    return new ResolveTransformStory<T>(this, types, conditionHandler, incidentHandler, memory);
  }

  @NotNull
  public <E1 extends Throwable> Story<T> resolveWhileTransform(
      @NotNull final Class<? extends E1> firstType,
      @NotNull final StoryTransformer<? super Throwable, ? extends T> storyTransformer) {
    return resolveWhileTransform(firstType, storyTransformer, new ListMemory());
  }

  @NotNull
  public <E1 extends Throwable> Story<T> resolveWhileTransform(
      @NotNull final Class<? extends E1> firstType,
      @NotNull final StoryTransformer<? super Throwable, ? extends T> storyTransformer,
      @NotNull final Memory memory) {
    return resolveWhileTransform(firstType, new TransformerConditionHandler(storyTransformer),
        new TransformerEffectHandler<Throwable, T>(storyTransformer), memory);
  }

  @NotNull
  public <E extends Throwable> Story<T> resolveWhileTransform(
      @NotNull final Iterable<? extends Class<? extends E>> incidentTypes,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends T> incidentHandler) {
    return resolveWhileTransform(incidentTypes, conditionHandler, incidentHandler,
        new ListMemory());
  }

  @NotNull
  public <E extends Throwable> Story<T> resolveWhileTransform(
      @NotNull final Iterable<? extends Class<? extends E>> incidentTypes,
      @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
      @NotNull final UnaryFunction<? super Throwable, ? extends T> incidentHandler,
      @NotNull final Memory memory) {
    return new ResolveTransformStory<T>(this,
        Iterables.<Class<? extends Throwable>>toSet(incidentTypes), conditionHandler,
        incidentHandler, memory);
  }

  @NotNull
  public Story<T> scheduleAtFixedRate(final long initialDelay, final long period,
      @NotNull final TimeUnit unit) {
    return scheduleAtFixedRate(initialDelay, period, unit, new ListMemory());
  }

  @NotNull
  public Story<T> scheduleAtFixedRate(final long initialDelay, final long period,
      @NotNull final TimeUnit unit, @NotNull final Memory memory) {
    return new ScheduleAtFixedRateStory<T>(this, initialDelay, period, unit, memory);
  }

  @NotNull
  public Story<T> scheduleWithFixedDelay(final long initialDelay, final long delay,
      @NotNull final TimeUnit unit) {
    return scheduleWithFixedDelay(initialDelay, delay, unit, new ListMemory());
  }

  @NotNull
  public Story<T> scheduleWithFixedDelay(final long initialDelay, final long delay,
      @NotNull final TimeUnit unit, @NotNull final Memory memory) {
    return new ScheduleWithFixedDelayStory<T>(this, initialDelay, delay, unit, memory);
  }

  @NotNull
  public Story<T> watchAll(@Nullable final Observer<? super T> effectObserver) {
    return watchAll(effectObserver, new ListMemory());
  }

  @NotNull
  public Story<T> watchAll(@Nullable final Observer<? super T> effectObserver,
      @NotNull final Memory memory) {
    return forAllTransform(new WatchAllFunction<T>(effectObserver), memory);
  }

  @NotNull
  public Story<T> watchEach(@NotNull final EventObserver<? super T> eventObserver) {
    return watchEach(eventObserver, new ListMemory());
  }

  @NotNull
  public Story<T> watchEach(@NotNull final EventObserver<? super T> eventObserver,
      @NotNull final Memory memory) {
    return new WatchStory<T>(this, eventObserver, memory);
  }

  @NotNull
  public Story<T> watchEach(@Nullable final Observer<? super T> effectObserver,
      @Nullable final Observer<? super Throwable> incidentObserver) {
    return watchEach(effectObserver, incidentObserver, new ListMemory());
  }

  @NotNull
  public Story<T> watchEach(@Nullable final Observer<? super T> effectObserver,
      @Nullable final Observer<? super Throwable> incidentObserver, @NotNull final Memory memory) {
    return watchEach(new DefaultEventObserver<T>(effectObserver, incidentObserver), memory);
  }

  public interface StoryEvolver<T, R> {

    @Nullable
    Event<? extends Boolean> canContinue() throws Exception;

    @Nullable
    Story<R> evolve(T effect) throws Exception;
  }

  public interface StoryTransformer<T, R> {

    @Nullable
    Event<? extends Boolean> canContinue() throws Exception;

    R transform(T effect) throws Exception;
  }

  public static class StoryNarrator<T> extends Story<T> implements Narrator<T> {

    private final Actor actor;
    private final HashMap<String, Sender> getSenders = new HashMap<String, Sender>();
    private final AtomicBoolean isClosed = new AtomicBoolean();
    private final Memory memory;
    private final HashMap<String, SenderIterator> nextSenders =
        new HashMap<String, SenderIterator>();
    private final BlockingQueue<Object> queue;

    private volatile Throwable exception;

    private StoryNarrator(@NotNull final BlockingQueue<Object> queue,
        @NotNull final Memory memory) {
      this.queue = ConstantConditions.notNull("queue", queue);
      this.memory = ConstantConditions.notNull("memory", memory);
      actor = Stage.newActor(new PlotRole(Setting.get()) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new InitBehavior();
        }
      });
    }

    public void close() {
      if (!isClosed.getAndSet(true)) {
        if (exception == null) {
          exception = new NarrationStoppedException();
        }
        if (queue.isEmpty()) {
          actor.tell(AVAILABLE, null, Stage.STAND_IN);
        }
      }
    }

    public boolean report(@NotNull final Throwable incident, final long timeout,
        @NotNull final TimeUnit unit) throws InterruptedException {
      return enqueue(new Conflict(incident), timeout, unit);
    }

    public boolean tell(final T effect, final long timeout, @NotNull final TimeUnit unit) throws
        InterruptedException {
      return enqueue((effect != null) ? effect : NULL, timeout, unit);
    }

    private void cancel(@NotNull final Throwable cause) {
      if (exception == null) {
        exception = cause;
      }
      queue.clear();
    }

    private void done(@NotNull final Agent agent) {
      done(memory, getSenders, nextSenders, agent);
    }

    private boolean enqueue(@NotNull final Object resolution, final long timeout,
        @NotNull final TimeUnit unit) throws InterruptedException {
      final Throwable exception = this.exception;
      if (exception != null) {
        if (exception instanceof RuntimeException) {
          throw (RuntimeException) exception;

        } else {
          throw new PlotFailureException(exception);
        }
      }
      final BlockingQueue<Object> queue = this.queue;
      final boolean wasEmpty = queue.isEmpty();
      if (queue.offer(resolution, timeout, unit)) {
        if (wasEmpty) {
          actor.tell(AVAILABLE, null, Stage.STAND_IN);
        }
        return true;
      }
      return false;
    }

    private boolean next(@NotNull final Agent agent) {
      final Actor self = agent.getSelf();
      final BlockingQueue<Object> queue = this.queue;
      final Memory memory = this.memory;
      Object effect = queue.poll();
      if (effect != null) {
        if (effect == NULL) {
          effect = null;
        }
        memory.put(effect);
        for (final SenderIterator sender : nextSenders.values()) {
          sender.tellNext(self);
        }

      } else if (isClosed.get()) {
        done(agent);
        return false;
      }

      if (!getSenders.isEmpty()) {
        while ((effect = queue.poll()) != null) {
          if (effect == NULL) {
            effect = null;
          }
          memory.put(effect);
        }
      }
      return true;
    }

    private class InitBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
          if (next(agent)) {
            agent.setBehavior(new InputBehavior());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders().threadOnly();
          final SenderIterator sender = new SenderIterator(envelop.getSender(), headers);
          sender.setIterator(memory.iterator());
          nextSenders.put(headers.getThreadId(), sender);
          if (next(agent)) {
            agent.setBehavior(new InputBehavior());
          }

        } else if (message == CANCEL) {
          final Conflict conflict = Conflict.ofCancel();
          cancel(conflict.getCause());
          agent.setBehavior(
              new DoneBehavior(conflict, Collections.singleton(conflict), nextSenders));
        }
        envelop.preventReceipt();
      }
    }

    private class InputBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final HashMap<String, Sender> getSenders = StoryNarrator.this.getSenders;
          final boolean wasEmpty = getSenders.isEmpty();
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
          if (wasEmpty) {
            next(agent);
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = StoryNarrator.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          if (!sender.tellNext(agent.getSelf())) {
            next(agent);
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == AVAILABLE) {
          next(agent);

        } else if (message == CANCEL) {
          final Conflict conflict = Conflict.ofCancel();
          cancel(conflict.getCause());
          agent.setBehavior(
              new DoneBehavior(conflict, Collections.singleton(conflict), nextSenders));
        }
        envelop.preventReceipt();
      }
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  static class ActorStory<T> extends AbstractStory<T> {

    private final List<Actor> actors;

    ActorStory(@NotNull final Actor actor, @NotNull final Memory memory) {
      super(INFINITE_LOOP, 1, memory);
      actors = Collections.singletonList(actor);
    }

    @NotNull
    List<Actor> getInputActors() {
      return actors;
    }
  }

  static class DefaultStoryObserver<T> extends DefaultEventObserver<T> implements StoryObserver<T> {

    private final Action endAction;

    DefaultStoryObserver(@Nullable final Observer<? super T> effectObserver,
        @Nullable final Observer<? super Throwable> incidentObserver,
        @Nullable final Action endAction) {
      super(effectObserver, incidentObserver);
      this.endAction = (endAction != null) ? endAction : NO_OP;
    }

    public void onEnd() throws Exception {
      endAction.run();
    }
  }

  static class EventStoryObserver<T> implements StoryObserver<T> {

    private final EventObserver<? super T> eventObserver;

    EventStoryObserver(@NotNull final EventObserver<? super T> eventObserver) {
      this.eventObserver = ConstantConditions.notNull("eventObserver", eventObserver);
    }

    public void onEffect(final T effect) throws Exception {
      eventObserver.onEffect(effect);
    }

    public void onIncident(@NotNull final Throwable incident) throws Exception {
      eventObserver.onIncident(incident);
    }

    public void onEnd() {
    }
  }

  private abstract static class AbstractStory<T> extends Story<T> {

    private final Actor actor;
    private final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler;
    private final String continueThread;
    private final HashMap<String, Sender> getSenders = new HashMap<String, Sender>();
    private final Headers headers;
    private final HashMap<Actor, Headers> inputActors = new HashMap<Actor, Headers>();
    private final String inputThread;
    private final Object[] inputs;
    private final HashMap<String, SenderIterator> nextSenders =
        new HashMap<String, SenderIterator>();
    private final String outputThread;
    private final Setting setting;

    private Conflict conflict;
    private Actor continueActor;
    private int continueCount;
    private Headers continueHeaders;
    private Conflict getConflict;
    private int inputCount;
    private Memory memory;
    private Actor outputActor;
    private Headers outputHeaders;

    private AbstractStory(
        @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
        final int numInputs, @NotNull final Memory memory) {
      this.conditionHandler = ConstantConditions.notNull("conditionHandler", conditionHandler);
      inputs = new Object[numInputs];
      this.memory = ConstantConditions.notNull("memory", memory);
      final Setting setting = (this.setting = Setting.get());
      final String actorId = (actor = Stage.newActor(new PlotRole(setting) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new InitBehavior();
        }
      })).getId();
      continueThread = actorId + ":continue";
      inputThread = actorId + ":input";
      outputThread = actorId + ":output";
      headers = new Headers().withReceiptId(actorId);
    }

    void endAction() throws Exception {
    }

    @Nullable
    Actor getConflictActor(@NotNull final Conflict conflict, @NotNull final Agent agent) throws
        Exception {
      putConflict(conflict, agent);
      return null;
    }

    @NotNull
    abstract List<Actor> getInputActors();

    @Nullable
    Actor getOutputActor(@NotNull final Object[] inputs, @NotNull final Agent agent) throws
        Exception {
      putEffect(inputs[0], agent);
      return null;
    }

    @NotNull
    Setting getSetting() {
      return setting;
    }

    void putConflict(@NotNull final Conflict conflict, @NotNull final Agent agent) {
      memory.put(conflict);
      final Actor self = agent.getSelf();
      for (final SenderIterator sender : nextSenders.values()) {
        sender.tellNext(self);
      }
    }

    void putEffect(final Object effect, @NotNull final Agent agent) {
      memory.put(effect);
      final Actor self = agent.getSelf();
      for (final SenderIterator sender : nextSenders.values()) {
        sender.tellNext(self);
      }
    }

    private void cancelInputActors(@NotNull final Agent agent) {
      final Actor self = agent.getSelf();
      for (final Actor actor : getInputActors()) {
        actor.tell(CANCEL, null, self);
      }
    }

    private void conflict(@NotNull Conflict conflict, @NotNull final Agent agent) {
      Actor conflictActor = null;
      try {
        conflictActor = getConflictActor(conflict, agent);

      } catch (final Throwable t) {
        conflict = new Conflict(t);
        if (t instanceof InterruptedException) {
          Thread.currentThread().interrupt();
        }
      }

      final Actor self = agent.getSelf();
      if (conflictActor != null) {
        (outputActor = conflictActor).tell(GET, outputHeaders, self);
        agent.setBehavior(new OutputBehavior());

      } else {
        memory.put(conflict);
        for (final SenderIterator sender : nextSenders.values()) {
          sender.tellNext(self);
        }

        if (!getSenders.isEmpty()) {
          getConflict = conflict;
          for (final Sender sender : getSenders.values()) {
            sender.getSender().tell(conflict, sender.getHeaders(), self);
          }
          getSenders.clear();
        }
        agent.setBehavior(new NextContinueBehavior());
      }
    }

    private void done(@NotNull final Agent agent) {
      final Memory memory = this.memory;
      try {
        endAction();

      } catch (final Throwable t) {
        memory.put(new Conflict(t));
        if (t instanceof InterruptedException) {
          Thread.currentThread().interrupt();
        }
      }
      done(memory, getSenders, nextSenders, agent);
    }

    private void fail(@NotNull Conflict conflict, @NotNull final Agent agent) {
      tellInputActors(BREAK, agent);
      final Actor outputActor = this.outputActor;
      if (outputActor != null) {
        outputActor.tell(BREAK, outputHeaders, agent.getSelf());
      }

      try {
        endAction();

      } catch (final Throwable t) {
        conflict = new Conflict(t);
        if (t instanceof InterruptedException) {
          Thread.currentThread().interrupt();
        }
      }
      fail(conflict, memory, getSenders, nextSenders, agent);
    }

    private void next(final int loopCount, @NotNull final Agent agent) {
      Setting.set(getSetting());
      try {
        final Event<? extends Boolean> event;
        Setting.set(getSetting());
        try {
          event = conditionHandler.call();

        } finally {
          Setting.unset();
        }

        if ((event == null) || Event.isFalse(event) || Event.isNull(event)) {
          done(agent);

        } else if (Event.isTrue(event)) {
          setThreadIds(loopCount);
          tellInputActors(NEXT, agent);
          agent.setBehavior(new InputBehavior());

        } else {
          setThreadIds(loopCount);
          (continueActor = event.getActor()).tell(GET, continueHeaders, agent.getSelf());
          agent.setBehavior(new ContinueBehavior());
        }

      } catch (final Throwable t) {
        fail(new Conflict(t), agent);
        if (t instanceof InterruptedException) {
          Thread.currentThread().interrupt();
        }
      }
    }

    private void setThreadIds(final int count) {
      final Headers headers = this.headers;
      continueHeaders = headers.withThreadId(continueThread + "#" + count);
      outputHeaders = headers.withThreadId(outputThread + "#" + count);
    }

    private void tellInputActors(final Object message, @NotNull final Agent agent) {
      final Actor self = agent.getSelf();
      final HashMap<Actor, Headers> inputActors = this.inputActors;
      if (inputActors.isEmpty()) {
        final Headers headers = this.headers;
        final String inputThread = this.inputThread;
        final StringBuilder builder = new StringBuilder();
        for (final Actor actor : getInputActors()) {
          final String threadId = inputThread + builder.append('#').toString();
          final Headers inputHeaders = headers.withThreadId(threadId);
          inputActors.put(actor, inputHeaders);
          actor.tell(message, inputHeaders, self);
        }

      } else {
        for (final Entry<Actor, Headers> entry : inputActors.entrySet()) {
          entry.getKey().tell(message, entry.getValue(), self);
        }
      }
    }

    private class CancelBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Conflict conflict = getConflict;
          final Headers headers = envelop.getHeaders().threadOnly();
          if (conflict == null) {
            getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

          } else {
            envelop.getSender().tell(conflict, headers, agent.getSelf());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = AbstractStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          sender.tellNext(agent.getSelf());

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else {
          final Headers outputHeaders = AbstractStory.this.outputHeaders;
          if (isSame(outputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            outputActor.tell(BREAK, outputHeaders, agent.getSelf());
            fail(Conflict.ofCancel(), agent);

          } else {
            final String threadId = envelop.getHeaders().getThreadId();
            if ((threadId != null) && threadId.startsWith(inputThread)) {
              if (++inputCount == inputs.length) {
                final Conflict conflict = Conflict.ofCancel();
                try {
                  final Actor conflictActor = getConflictActor(conflict, agent);
                  if (conflictActor != null) {
                    conflictActor.tell(CANCEL, null, agent.getSelf());
                  }
                  fail(conflict, agent);

                } catch (final Throwable t) {
                  fail(new Conflict(t), agent);
                  if (t instanceof InterruptedException) {
                    Thread.currentThread().interrupt();
                  }
                }
              }
            }
          }
        }
      }
    }

    private class ContinueBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Conflict conflict = getConflict;
          final Headers headers = envelop.getHeaders().threadOnly();
          if (conflict == null) {
            getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

          } else {
            envelop.getSender().tell(conflict, headers, agent.getSelf());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = AbstractStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          sender.tellNext(agent.getSelf());

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          continueActor.tell(CANCEL, null, agent.getSelf());
          cancelInputActors(agent);
          agent.setBehavior(new CancelBehavior());

        } else {
          final String threadId = envelop.getHeaders().getThreadId();
          if (isSame(continueHeaders.getThreadId(), threadId)) {
            if (message instanceof Conflict) {
              fail((Conflict) message, agent);

            } else if (message instanceof Bounce) {
              fail(Conflict.ofBounce((Bounce) message), agent);

            } else {
              if (Boolean.TRUE.equals(message)) {
                tellInputActors(NEXT, agent);
                agent.setBehavior(new InputBehavior());

              } else {
                done(agent);
              }
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    private class InitBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
          next(continueCount, agent);

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders().threadOnly();
          final SenderIterator sender = new SenderIterator(envelop.getSender(), headers);
          sender.setIterator(memory.iterator());
          nextSenders.put(headers.getThreadId(), sender);
          next(continueCount, agent);

        } else if (message == CANCEL) {
          cancelInputActors(agent);
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class InputBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Conflict conflict = getConflict;
          final Headers headers = envelop.getHeaders().threadOnly();
          if (conflict == null) {
            getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

          } else {
            envelop.getSender().tell(conflict, headers, agent.getSelf());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = AbstractStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          sender.tellNext(agent.getSelf());

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          cancelInputActors(agent);
          agent.setBehavior(new CancelBehavior());

        } else {
          final String inputThread = AbstractStory.this.inputThread;
          final String threadId = envelop.getHeaders().getThreadId();
          if ((threadId != null) && threadId.startsWith(inputThread)) {
            if (message == END) {
              tellInputActors(BREAK, agent);
              done(agent);

            } else if (message instanceof Conflict) {
              if (conflict == null) {
                conflict = (Conflict) message;
              }

              if (++inputCount == inputs.length) {
                conflict = null;
                inputCount = 0;
                conflict((Conflict) message, agent);
              }

            } else if (message instanceof Bounce) {
              final Conflict conflict = Conflict.ofBounce((Bounce) message);
              if (AbstractStory.this.conflict == null) {
                AbstractStory.this.conflict = conflict;
              }

              if (++inputCount == inputs.length) {
                AbstractStory.this.conflict = null;
                inputCount = 0;
                conflict(conflict, agent);
              }

            } else {
              final int index = threadId.length() - inputThread.length() - 1;
              final Object[] inputs = AbstractStory.this.inputs;
              if ((index >= 0) && (index < inputs.length)) {
                inputs[index] = message;
                if (++inputCount == inputs.length) {
                  inputCount = 0;
                  if (conflict != null) {
                    final Conflict conflict = AbstractStory.this.conflict;
                    AbstractStory.this.conflict = null;
                    conflict(conflict, agent);

                  } else {
                    try {
                      Actor outputActor = getOutputActor(inputs, agent);
                      if (outputActor != null) {
                        (AbstractStory.this.outputActor = outputActor).tell(NEXT, outputHeaders, agent.getSelf());
                        agent.setBehavior(new OutputBehavior());

                      } else {
                        if (!getSenders.isEmpty()) {
                          next(++continueCount, agent);

                        } else {
                          agent.setBehavior(new NextContinueBehavior());
                        }
                      }

                    } catch (final Throwable t) {
                      conflict(new Conflict(t), agent);
                      if (t instanceof InterruptedException) {
                        Thread.currentThread().interrupt();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    private class NextContinueBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Conflict conflict = getConflict;
          final Headers headers = envelop.getHeaders().threadOnly();
          if (conflict == null) {
            getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
            next(++continueCount, agent);

          } else {
            envelop.getSender().tell(conflict, headers, agent.getSelf());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = AbstractStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          final Actor self = agent.getSelf();
          if (!sender.tellNext(self)) {
            next(++continueCount, agent);
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          cancelInputActors(agent);
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class NextOutputBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Conflict conflict = getConflict;
          final Headers headers = envelop.getHeaders().threadOnly();
          if (conflict == null) {
            getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
            outputActor.tell(NEXT, outputHeaders, agent.getSelf());
            agent.setBehavior(new OutputBehavior());

          } else {
            envelop.getSender().tell(conflict, headers, agent.getSelf());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = AbstractStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          final Actor self = agent.getSelf();
          if (!sender.tellNext(self)) {
            outputActor.tell(NEXT, outputHeaders, self);
            agent.setBehavior(new OutputBehavior());
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          final Actor self = agent.getSelf();
          outputActor.tell(BREAK, outputHeaders, self).tell(CANCEL, null, self);
          cancelInputActors(agent);
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class OutputBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Conflict conflict = getConflict;
          final Headers headers = envelop.getHeaders().threadOnly();
          if (conflict == null) {
            getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

          } else {
            envelop.getSender().tell(conflict, headers, agent.getSelf());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = AbstractStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          sender.tellNext(agent.getSelf());

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          outputActor.tell(CANCEL, null, agent.getSelf());
          cancelInputActors(agent);
          agent.setBehavior(new CancelBehavior());

        } else {
          final Headers outputHeaders = AbstractStory.this.outputHeaders;
          if (isSame(outputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            if (message == END) {
              outputActor.tell(BREAK, outputHeaders, agent.getSelf());
              next(++continueCount, agent);

            } else if (message instanceof Bounce) {
              fail(Conflict.ofBounce((Bounce) message), agent);

            } else {
              // pass on conflicts
              memory.put(message);
              final Actor self = agent.getSelf();
              for (final SenderIterator sender : nextSenders.values()) {
                sender.tellNext(self);
              }

              if (!getSenders.isEmpty()) {
                outputActor.tell(NEXT, outputHeaders, self);

              } else {
                agent.setBehavior(new NextOutputBehavior());
              }
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class AllStory<T, R> extends Story<R> {

    private final Actor actor;
    private final UnaryFunction<? super T, ? extends Story<? extends R>> effectHandler;
    private final HashMap<String, Sender> getSenders = new HashMap<String, Sender>();
    private final Headers headers;
    private final Actor inputActor;
    private final Headers inputHeaders;
    private final Memory memory;
    private final HashMap<String, SenderIterator> nextSenders =
        new HashMap<String, SenderIterator>();
    private final String outputThread;
    private final Setting setting;

    private Conflict getConflict;
    private Iterator<?> inputIterator;
    private Actor outputActor;
    private int outputCount;
    private Headers outputHeaders;

    private AllStory(@NotNull final Story<? extends T> story,
        @NotNull final UnaryFunction<? super T, ? extends Story<? extends R>> effectHandler,
        @NotNull final Memory memory) {
      inputActor = story.getActor();
      this.effectHandler = ConstantConditions.notNull("effectHandler", effectHandler);
      this.memory = ConstantConditions.notNull("memory", memory);
      final Setting setting = (this.setting = Setting.get());
      final String actorId = (actor = Stage.newActor(new PlotRole(setting) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new InitBehavior();
        }
      })).getId();
      final Headers headers = (this.headers = new Headers().withReceiptId(actorId));
      outputThread = actorId + ":output";
      inputHeaders = headers.withThreadId(actorId + ":input");
    }

    private void conflict(@NotNull final Conflict conflict, @NotNull final Agent agent) {
      final Actor self = agent.getSelf();
      memory.put(conflict);
      for (final SenderIterator sender : nextSenders.values()) {
        sender.tellNext(self);
      }

      if (!getSenders.isEmpty()) {
        getConflict = conflict;
        for (final Sender sender : getSenders.values()) {
          sender.getSender().tell(conflict, sender.getHeaders(), self);
        }
        getSenders.clear();
      }
      agent.setBehavior(new NextBehavior());
    }

    private void done(@NotNull final Agent agent) {
      done(memory, getSenders, nextSenders, agent);
    }

    private void fail(@NotNull final Conflict conflict, @NotNull final Agent agent) {
      final Actor outputActor = this.outputActor;
      if (outputActor != null) {
        outputActor.tell(BREAK, outputHeaders, agent.getSelf());
      }
      fail(conflict, memory, getSenders, nextSenders, agent);
    }

    @Nullable
    @SuppressWarnings("unchecked")
    private Actor getNextOutputActor() throws Exception {
      final Iterator<?> inputIterator = this.inputIterator;
      if (!inputIterator.hasNext()) {
        return null;
      }
      Actor actor;
      Setting.set(setting);
      try {
        do {
          final Object input = inputIterator.next();
          final Story<? extends R> story = effectHandler.call((T) input);
          if ((story == null) || isEmpty(story)) {
            actor = null;

          } else {
            actor = story.getActor();
          }

        } while ((actor == null) && inputIterator.hasNext());
        return actor;

      } finally {
        Setting.unset();
      }
    }

    private void nextOutput(@NotNull final Behavior behavior, @NotNull final Agent agent) {
      try {
        final Actor outputActor = (this.outputActor = getNextOutputActor());
        if (outputActor != null) {
          final String outputThreadId = outputThread + "#" + outputCount++;
          final Headers headers = (outputHeaders = this.headers.withThreadId(outputThreadId));
          outputActor.tell(NEXT, headers, agent.getSelf());
          agent.setBehavior(behavior);

        } else {
          done(agent);
        }

      } catch (final Throwable t) {
        conflict(new Conflict(t), agent);
        if (t instanceof InterruptedException) {
          Thread.currentThread().interrupt();
        }
      }
    }

    private class CancelBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Conflict conflict = getConflict;
          final Headers headers = envelop.getHeaders().threadOnly();
          if (conflict == null) {
            getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

          } else {
            envelop.getSender().tell(conflict, headers, agent.getSelf());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = AllStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          sender.tellNext(agent.getSelf());

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
          fail(Conflict.ofCancel(), agent);

        } else {
          final Headers outputHeaders = AllStory.this.outputHeaders;
          if (isSame(outputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            outputActor.tell(BREAK, AllStory.this.outputHeaders, agent.getSelf());
            fail(Conflict.ofCancel(), agent);
          }
        }
        envelop.preventReceipt();
      }
    }

    private class InitBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
          inputActor.tell(GET, inputHeaders, agent.getSelf());
          agent.setBehavior(new InputBehavior());

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders().threadOnly();
          final SenderIterator sender = new SenderIterator(envelop.getSender(), headers);
          sender.setIterator(memory.iterator());
          nextSenders.put(headers.getThreadId(), sender);
          inputActor.tell(GET, inputHeaders, agent.getSelf());
          agent.setBehavior(new InputBehavior());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class InputBehavior extends AbstractBehavior {

      public void onMessage(Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Conflict conflict = getConflict;
          final Headers headers = envelop.getHeaders().threadOnly();
          if (conflict == null) {
            getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

          } else {
            envelop.getSender().tell(conflict, headers, agent.getSelf());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = AllStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          agent.setBehavior(new CancelBehavior());

        } else if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
          if (message instanceof Conflict) {
            fail((Conflict) message, agent);

          } else if (message instanceof Bounce) {
            fail(Conflict.ofBounce((Bounce) message), agent);

          } else {
            inputIterator = ((Iterable<?>) message).iterator();
            nextOutput(new OutputBehavior(), agent);
          }
        }
        envelop.preventReceipt();
      }
    }

    private class NextBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Conflict conflict = getConflict;
          final Headers headers = envelop.getHeaders().threadOnly();
          if (conflict == null) {
            getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
            nextOutput(new OutputBehavior(), agent);

          } else {
            envelop.getSender().tell(conflict, headers, agent.getSelf());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = AllStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          final Actor self = agent.getSelf();
          if (!sender.tellNext(self)) {
            nextOutput(new OutputBehavior(), agent);
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class NextOutputBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Conflict conflict = getConflict;
          final Headers headers = envelop.getHeaders().threadOnly();
          if (conflict == null) {
            getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
            outputActor.tell(NEXT, outputHeaders, agent.getSelf());
            agent.setBehavior(new OutputBehavior());

          } else {
            envelop.getSender().tell(conflict, headers, agent.getSelf());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = AllStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          final Actor self = agent.getSelf();
          if (!sender.tellNext(self)) {
            outputActor.tell(NEXT, outputHeaders, self);
            agent.setBehavior(new OutputBehavior());
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          final Actor self = agent.getSelf();
          outputActor.tell(BREAK, outputHeaders, self).tell(CANCEL, null, self);
          inputActor.tell(CANCEL, null, self);
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class OutputBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Conflict conflict = getConflict;
          final Headers headers = envelop.getHeaders().threadOnly();
          if (conflict == null) {
            getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

          } else {
            envelop.getSender().tell(conflict, headers, agent.getSelf());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = AllStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          sender.tellNext(agent.getSelf());

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          final Actor self = agent.getSelf();
          outputActor.tell(CANCEL, null, self);
          inputActor.tell(CANCEL, null, self);
          agent.setBehavior(new CancelBehavior());

        } else {
          final Headers outputHeaders = AllStory.this.outputHeaders;
          if (isSame(outputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            if (message == END) {
              final Actor self = agent.getSelf();
              outputActor.tell(BREAK, outputHeaders, self);
              nextOutput(this, agent);

            } else if (message instanceof Bounce) {
              memory.put(Conflict.ofBounce((Bounce) message));
              final Actor self = agent.getSelf();
              for (final SenderIterator sender : nextSenders.values()) {
                sender.tellNext(self);
              }
              nextOutput(this, agent);

            } else {
              // pass on conflicts
              memory.put(message);
              final Actor self = agent.getSelf();
              for (final SenderIterator sender : nextSenders.values()) {
                sender.tellNext(self);
              }

              if (!getSenders.isEmpty()) {
                outputActor.tell(NEXT, outputHeaders, self);

              } else {
                agent.setBehavior(new NextOutputBehavior());
              }
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class AllTransformStory<T, R> extends Story<R> {

    private final Actor actor;
    private final UnaryFunction<? super T, ? extends R> effectHandler;
    private final HashMap<String, Sender> getSenders = new HashMap<String, Sender>();
    private final Actor inputActor;
    private final Headers inputHeaders;
    private final Memory memory;
    private final HashMap<String, SenderIterator> nextSenders =
        new HashMap<String, SenderIterator>();
    private final Setting setting;

    private Conflict getConflict;
    private Iterator<?> inputIterator;

    private AllTransformStory(@NotNull final Story<? extends T> story,
        @NotNull final UnaryFunction<? super T, ? extends R> effectHandler,
        @NotNull final Memory memory) {
      inputActor = story.getActor();
      this.effectHandler = ConstantConditions.notNull("effectHandler", effectHandler);
      this.memory = ConstantConditions.notNull("memory", memory);
      final Setting setting = (this.setting = Setting.get());
      final String actorId = (actor = Stage.newActor(new PlotRole(setting) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new InitBehavior();
        }
      })).getId();
      inputHeaders = new Headers().withReceiptId(actorId).withThreadId(actorId + ":input");
    }

    private void conflict(@NotNull final Conflict conflict, @NotNull final Agent agent) {
      final Actor self = agent.getSelf();
      memory.put(conflict);
      for (final SenderIterator sender : nextSenders.values()) {
        sender.tellNext(self);
      }

      if (!getSenders.isEmpty()) {
        getConflict = conflict;
        for (final Sender sender : getSenders.values()) {
          sender.getSender().tell(conflict, sender.getHeaders(), self);
        }
        getSenders.clear();
      }
      agent.setBehavior(new NextBehavior());
    }

    private void done(@NotNull final Agent agent) {
      done(memory, getSenders, nextSenders, agent);
    }

    private void fail(@NotNull final Conflict conflict, @NotNull final Agent agent) {
      fail(conflict, memory, getSenders, nextSenders, agent);
    }

    @SuppressWarnings({"unchecked", "LoopConditionNotUpdatedInsideLoop"})
    private void nextOutput(@NotNull final Behavior behavior, @NotNull final Agent agent) {
      try {
        final Iterator<?> inputIterator = this.inputIterator;
        final boolean hasGetSenders = !getSenders.isEmpty();
        do {
          if (inputIterator.hasNext()) {
            Setting.set(setting);
            try {
              final R effect = effectHandler.call((T) inputIterator.next());
              memory.put(effect);
              final Actor self = agent.getSelf();
              for (final SenderIterator sender : nextSenders.values()) {
                sender.tellNext(self);
              }

            } finally {
              Setting.unset();
            }
            agent.setBehavior(behavior);

          } else {
            done(agent);
            break;
          }

        } while (hasGetSenders);

      } catch (final Throwable t) {
        conflict(new Conflict(t), agent);
        if (t instanceof InterruptedException) {
          Thread.currentThread().interrupt();
        }
      }
    }

    private class CancelBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Conflict conflict = getConflict;
          final Headers headers = envelop.getHeaders().threadOnly();
          if (conflict == null) {
            getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

          } else {
            envelop.getSender().tell(conflict, headers, agent.getSelf());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = AllTransformStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          sender.tellNext(agent.getSelf());

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class InitBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
          inputActor.tell(GET, inputHeaders, agent.getSelf());
          agent.setBehavior(new InputBehavior());

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders().threadOnly();
          final SenderIterator sender = new SenderIterator(envelop.getSender(), headers);
          sender.setIterator(memory.iterator());
          nextSenders.put(headers.getThreadId(), sender);
          inputActor.tell(GET, inputHeaders, agent.getSelf());
          agent.setBehavior(new InputBehavior());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class InputBehavior extends AbstractBehavior {

      public void onMessage(Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Conflict conflict = getConflict;
          final Headers headers = envelop.getHeaders().threadOnly();
          if (conflict == null) {
            getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

          } else {
            envelop.getSender().tell(conflict, headers, agent.getSelf());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = AllTransformStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          agent.setBehavior(new CancelBehavior());

        } else if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
          if (message instanceof Conflict) {
            fail((Conflict) message, agent);

          } else if (message instanceof Bounce) {
            fail(Conflict.ofBounce((Bounce) message), agent);

          } else {
            inputIterator = ((Iterable<?>) message).iterator();
            nextOutput(new NextBehavior(), agent);
          }
        }
        envelop.preventReceipt();
      }
    }

    private class NextBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Conflict conflict = getConflict;
          final Headers headers = envelop.getHeaders().threadOnly();
          if (conflict == null) {
            getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
            nextOutput(this, agent);

          } else {
            envelop.getSender().tell(conflict, headers, agent.getSelf());
          }

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = AllTransformStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          final Actor self = agent.getSelf();
          if (!sender.tellNext(self)) {
            nextOutput(this, agent);
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class BlendStory<T, R> extends Story<R> {

    private final Actor actor;
    private final UnaryFunction<? super T, ? extends Story<? extends R>> effectHandler;
    private final HashMap<String, Sender> getSenders = new HashMap<String, Sender>();
    private final Headers headers;
    private final Actor inputActor;
    private final Headers inputHeaders;
    private final int maxConcurrency;
    private final Memory memory;
    private final HashMap<Actor, Headers> nextActors = new HashMap<Actor, Headers>();
    private final HashMap<String, SenderIterator> nextSenders =
        new HashMap<String, SenderIterator>();
    private final HashMap<Actor, Headers> outputActors = new HashMap<Actor, Headers>();
    private final String outputThread;
    private final Setting setting;

    private Conflict inputConflict;
    private boolean inputsEnded;
    private boolean inputsPending;
    private long outputCount;

    private BlendStory(@NotNull final Story<? extends T> story, final int maxConcurrency,
        @NotNull final UnaryFunction<? super T, ? extends Story<? extends R>> effectHandler,
        @NotNull final Memory memory) {
      inputActor = story.getActor();
      this.maxConcurrency = ConstantConditions.positive("maxConcurrency", maxConcurrency);
      this.effectHandler = ConstantConditions.notNull("effectHandler", effectHandler);
      this.memory = ConstantConditions.notNull("memory", memory);
      final Setting setting = (this.setting = Setting.get());
      final String actorId = (actor = Stage.newActor(new PlotRole(setting) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new InitBehavior();
        }
      })).getId();
      final Headers headers = (this.headers = new Headers().withReceiptId(actorId));
      outputThread = actorId + ":output";
      inputHeaders = headers.withThreadId(actorId + ":input");
    }

    private void done(@NotNull final Agent agent) {
      done(memory, getSenders, nextSenders, agent);
    }

    private void fail(@NotNull final Conflict conflict, @NotNull final Agent agent) {
      fail(conflict, memory, getSenders, nextSenders, agent);
    }

    @Nullable
    @SuppressWarnings("unchecked")
    private Actor getOutputActor(@NotNull final Object input) throws Exception {
      Setting.set(setting);
      try {
        final Story<? extends R> story = effectHandler.call((T) input);
        if ((story == null) || isEmpty(story)) {
          return null;
        }
        return story.getActor();

      } finally {
        Setting.unset();
      }
    }

    private class CancelBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = BlendStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          sender.tellNext(agent.getSelf());

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else {
          final Headers inputHeaders = BlendStory.this.inputHeaders;
          if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            inputActor.tell(BREAK, inputHeaders, agent.getSelf());
            inputsEnded = true;
            if (outputActors.isEmpty()) {
              fail(Conflict.ofCancel(), agent);
            }

          } else {
            final String threadId = envelop.getHeaders().getThreadId();
            if ((threadId != null) && threadId.startsWith(outputThread)) {
              final HashMap<Actor, Headers> outputActors = BlendStory.this.outputActors;
              final Actor sender = envelop.getSender();
              sender.tell(BREAK, outputActors.get(sender), agent.getSelf());
              outputActors.remove(sender);
              if (outputActors.isEmpty() && inputsEnded) {
                fail(Conflict.ofCancel(), agent);
              }
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    private class InitBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
          inputActor.tell(NEXT, inputHeaders, agent.getSelf());
          agent.setBehavior(new InputBehavior());

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders().threadOnly();
          final SenderIterator sender = new SenderIterator(envelop.getSender(), headers);
          sender.setIterator(memory.iterator());
          nextSenders.put(headers.getThreadId(), sender);
          inputActor.tell(NEXT, inputHeaders, agent.getSelf());
          agent.setBehavior(new InputBehavior());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class InputBehavior extends AbstractBehavior {

      public void onMessage(Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = BlendStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          agent.setBehavior(new CancelBehavior());

        } else {
          final Headers inputHeaders = BlendStory.this.inputHeaders;
          if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            if (message == END) {
              inputActor.tell(BREAK, inputHeaders, agent.getSelf());
              done(agent);

            } else if (message instanceof Conflict) {
              inputActor.tell(BREAK, inputHeaders, agent.getSelf());
              fail((Conflict) message, agent);

            } else if (message instanceof Bounce) {
              fail(Conflict.ofBounce((Bounce) message), agent);

            } else {
              try {
                final Actor outputActor = getOutputActor(message);
                if (outputActor != null) {
                  final String outputThreadId = outputThread + "#" + outputCount++;
                  final Headers headers = BlendStory.this.headers.withThreadId(outputThreadId);
                  final HashMap<Actor, Headers> outputActors = BlendStory.this.outputActors;
                  outputActors.put(outputActor, headers);
                  outputActor.tell(NEXT, headers, agent.getSelf());
                  if ((inputsPending = outputActors.size() < maxConcurrency)) {
                    inputActor.tell(NEXT, inputHeaders, agent.getSelf());
                  }
                  agent.setBehavior(new OutputBehavior());

                } else if ((inputsPending = outputActors.size() < maxConcurrency)) {
                  inputActor.tell(NEXT, inputHeaders, agent.getSelf());
                }

              } catch (final Throwable t) {
                inputActor.tell(BREAK, inputHeaders, agent.getSelf());
                fail(new Conflict(t), agent);
                if (t instanceof InterruptedException) {
                  Thread.currentThread().interrupt();
                }
              }
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    private class OutputBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
          final HashMap<Actor, Headers> nextActors = BlendStory.this.nextActors;
          final Actor self = agent.getSelf();
          for (final Entry<Actor, Headers> entry : nextActors.entrySet()) {
            entry.getKey().tell(NEXT, entry.getValue(), self);
          }
          nextActors.clear();

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = BlendStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          final HashMap<Actor, Headers> outputActors = BlendStory.this.outputActors;
          if (!sender.tellNext(agent.getSelf()) && (nextActors.size() == outputActors.size())) {
            final Actor self = agent.getSelf();
            for (final Entry<Actor, Headers> entry : outputActors.entrySet()) {
              entry.getKey().tell(NEXT, entry.getValue(), self);
            }
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          final Actor self = agent.getSelf();
          for (final Actor outputActor : outputActors.keySet()) {
            outputActor.tell(CANCEL, null, self);
          }
          inputActor.tell(CANCEL, null, self);
          agent.setBehavior(new CancelBehavior());

        } else {
          final Headers inputHeaders = BlendStory.this.inputHeaders;
          if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            if (message == END) {
              inputActor.tell(BREAK, inputHeaders, agent.getSelf());
              inputsEnded = true;
              if (outputActors.isEmpty()) {
                done(agent);
              }

            } else if (message instanceof Conflict) {
              inputActor.tell(BREAK, inputHeaders, agent.getSelf());
              inputsEnded = true;
              final Conflict conflict = (inputConflict = (Conflict) message);
              if (outputActors.isEmpty()) {
                fail(conflict, agent);
              }

            } else if (message instanceof Bounce) {
              inputsEnded = true;
              final Conflict conflict = (inputConflict = Conflict.ofBounce((Bounce) message));
              if (outputActors.isEmpty()) {
                fail(conflict, agent);
              }

            } else {
              try {
                final Actor outputActor = getOutputActor(message);
                if (outputActor != null) {
                  final String outputThreadId = outputThread + "#" + outputCount++;
                  final Headers headers = BlendStory.this.headers.withThreadId(outputThreadId);
                  final HashMap<Actor, Headers> outputActors = BlendStory.this.outputActors;
                  outputActors.put(outputActor, headers);
                  outputActor.tell(NEXT, headers, agent.getSelf());
                  if ((inputsPending = outputActors.size() < maxConcurrency)) {
                    inputActor.tell(NEXT, inputHeaders, agent.getSelf());
                  }

                } else if ((inputsPending = outputActors.size() < maxConcurrency)) {
                  inputActor.tell(NEXT, inputHeaders, agent.getSelf());
                }

              } catch (final Throwable t) {
                inputsEnded = true;
                final Conflict conflict = (inputConflict = new Conflict(t));
                if (outputActors.isEmpty()) {
                  fail(conflict, agent);
                }

                if (t instanceof InterruptedException) {
                  Thread.currentThread().interrupt();
                }
              }
            }

          } else {
            final String threadId = envelop.getHeaders().getThreadId();
            if ((threadId != null) && threadId.startsWith(outputThread)) {
              if (message == END) {
                final Actor self = agent.getSelf();
                final Actor sender = envelop.getSender();
                sender.tell(BREAK, outputActors.get(sender), self);
                final HashMap<Actor, Headers> outputActors = BlendStory.this.outputActors;
                outputActors.remove(sender);
                if (!inputsEnded) {
                  if (!inputsPending) {
                    inputsPending = true;
                    inputActor.tell(NEXT, inputHeaders, self);
                  }

                } else if (outputActors.isEmpty()) {
                  final Conflict conflict = inputConflict;
                  if (conflict != null) {
                    fail(conflict, agent);

                  } else {
                    done(agent);
                  }
                }

              } else if (message instanceof Bounce) {
                memory.put(Conflict.ofBounce((Bounce) message));
                final Actor self = agent.getSelf();
                for (final SenderIterator sender : nextSenders.values()) {
                  sender.tellNext(self);
                }

                final HashMap<Actor, Headers> outputActors = BlendStory.this.outputActors;
                outputActors.remove(envelop.getSender());
                if (!inputsEnded) {
                  if (!inputsPending) {
                    inputsPending = true;
                    inputActor.tell(NEXT, inputHeaders, self);
                  }

                } else if (outputActors.isEmpty()) {
                  final Conflict conflict = inputConflict;
                  if (conflict != null) {
                    fail(conflict, agent);

                  } else {
                    done(agent);
                  }
                }

              } else {
                // pass on conflicts
                memory.put(message);
                final Actor self = agent.getSelf();
                for (final SenderIterator sender : nextSenders.values()) {
                  sender.tellNext(self);
                }

                final Actor sender = envelop.getSender();
                if (!getSenders.isEmpty()) {
                  sender.tell(NEXT, outputActors.get(sender), self);

                } else {
                  nextActors.put(sender, outputActors.get(sender));
                }
              }
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class DoneBehavior extends AbstractBehavior {

    private final Object effect;
    private final Iterable<?> effects;
    private final Map<String, SenderIterator> nextSenders;

    private DoneBehavior(final Object effect, @NotNull final Iterable<?> effects,
        @NotNull final Map<String, SenderIterator> nextSenders) {
      this.effect = effect;
      this.effects = effects;
      this.nextSenders = nextSenders;
    }

    public void onMessage(final Object message, @NotNull final Envelop envelop,
        @NotNull final Agent agent) {
      if (message == GET) {
        envelop.getSender().tell(effect, envelop.getHeaders().threadOnly(), agent.getSelf());

      } else if (message == NEXT) {
        final Actor self = agent.getSelf();
        final Headers headers = envelop.getHeaders().threadOnly();
        final String threadId = headers.getThreadId();
        final Map<String, SenderIterator> nextSenders = this.nextSenders;
        SenderIterator sender = nextSenders.get(threadId);
        if (sender != null) {
          sender.waitNext();

        } else {
          sender = new SenderIterator(envelop.getSender(), headers);
          sender.setIterator(effects.iterator());
          nextSenders.put(threadId, sender);
        }

        if (!sender.tellNext(self)) {
          sender.getSender().tell(END, headers, self);
        }

      } else if (message == BREAK) {
        nextSenders.remove(envelop.getHeaders().getThreadId());
      }
      envelop.preventReceipt();
    }
  }

  private static class EffectStory<T> extends Story<T> {

    private final Actor actor;

    private EffectStory(final T effect) {
      actor = Stage.newActor(new LocalPlotRole(Setting.get()) {

        private final HashSet<String> threadIds = new HashSet<String>();

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new AbstractBehavior() {

            public void onMessage(final Object message, @NotNull final Envelop envelop,
                @NotNull final Agent agent) {
              if (message == GET) {
                envelop.getSender()
                    .tell(effect, envelop.getHeaders().threadOnly(), agent.getSelf());

              } else if (message == NEXT) {
                final HashSet<String> threads = threadIds;
                final Headers headers = envelop.getHeaders().threadOnly();
                final String threadId = headers.getThreadId();
                if (!threads.contains(threadId)) {
                  envelop.getSender()
                      .tell(effect, envelop.getHeaders().threadOnly(), agent.getSelf());
                  threads.add(threadId);

                } else {
                  envelop.getSender()
                      .tell(END, envelop.getHeaders().threadOnly(), agent.getSelf());
                }

              } else if (message == BREAK) {
                threadIds.remove(envelop.getHeaders().getThreadId());
              }
              envelop.preventReceipt();
            }
          };
        }
      });
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class EffectsStory<T> extends Story<T> {

    private final Actor actor;

    private EffectsStory(@NotNull final Iterable<? extends T> effects) {
      ConstantConditions.notNull("effects", effects);
      actor = Stage.newActor(new LocalPlotRole(Setting.get()) {

        private final HashMap<String, Iterator<? extends T>> threadIds =
            new HashMap<String, Iterator<? extends T>>();

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new AbstractBehavior() {

            public void onMessage(final Object message, @NotNull final Envelop envelop,
                @NotNull final Agent agent) {
              if (message == GET) {
                envelop.getSender()
                    .tell(Iterables.toList(effects), envelop.getHeaders().threadOnly(),
                        agent.getSelf());

              } else if (message == NEXT) {
                final HashMap<String, Iterator<? extends T>> threads = threadIds;
                final Headers headers = envelop.getHeaders().threadOnly();
                final String threadId = headers.getThreadId();
                Iterator<? extends T> iterator = threads.get(threadId);
                if (iterator == null) {
                  iterator = effects.iterator();
                  threads.put(threadId, iterator);
                }
                envelop.getSender()
                    .tell(iterator.hasNext() ? iterator.next() : END, headers, agent.getSelf());

              } else if (message == BREAK) {
                threadIds.remove(envelop.getHeaders().getThreadId());
              }
              envelop.preventReceipt();
            }
          };
        }
      });
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class EventStory<T> extends Story<T> {

    private final Actor actor;
    private final HashMap<String, Sender> getSenders = new HashMap<String, Sender>();
    private final Actor inputActor;
    private final HashMap<String, SenderIterator> nextSenders =
        new HashMap<String, SenderIterator>();
    private final Headers headers;

    private EventStory(@NotNull final Event<? extends T> event) {
      inputActor = event.getActor();
      final String actorId = (actor = Stage.newActor(new LocalPlotRole(Setting.get()) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new InitBehavior();
        }
      })).getId();
      headers = new Headers().withReceiptId(actorId).withThreadId(actorId);
    }

    private void fail(@NotNull final Conflict conflict, @NotNull final Agent agent) {
      final SingletonMemory memory = new SingletonMemory();
      for (final SenderIterator sender : nextSenders.values()) {
        sender.setIterator(memory.iterator());
      }
      fail(conflict, memory, getSenders, nextSenders, agent);
    }

    private class CancelBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders().threadOnly();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = EventStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            nextSenders.put(threadId, sender);
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else {
          if (agent.getSelf().getId().equals(envelop.getHeaders().getThreadId())) {
            fail(Conflict.ofCancel(), agent);
          }
        }
        envelop.preventReceipt();
      }
    }

    private class InitBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
          inputActor.tell(GET, EventStory.this.headers, agent.getSelf());
          agent.setBehavior(new InputBehavior());

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders().threadOnly();
          nextSenders.put(headers.getThreadId(), new SenderIterator(envelop.getSender(), headers));
          inputActor.tell(GET, EventStory.this.headers, agent.getSelf());
          agent.setBehavior(new InputBehavior());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class InputBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders().threadOnly();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = EventStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            nextSenders.put(threadId, sender);
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          agent.setBehavior(new CancelBehavior());

        } else {
          final Actor self = agent.getSelf();
          if (self.getId().equals(envelop.getHeaders().getThreadId())) {
            if (message instanceof Conflict) {
              fail((Conflict) message, agent);

            } else if (message instanceof Bounce) {
              fail(Conflict.ofBounce((Bounce) message), agent);

            } else {
              for (final Sender sender : getSenders.values()) {
                sender.getSender().tell(message, sender.getHeaders(), self);
              }
              final Set<Object> effects = Collections.singleton(message);
              for (final SenderIterator sender : nextSenders.values()) {
                sender.setIterator(effects.iterator());
                sender.tellNext(self);
              }
              agent.setBehavior(new DoneBehavior(effects, effects, nextSenders));
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class EventualStory<T> extends AbstractStory<T> {

    private final List<Actor> actors;
    private final Action eventualAction;

    private EventualStory(@NotNull final Story<T> story, @NotNull final Action eventualAction,
        @NotNull final Memory memory) {
      super(INFINITE_LOOP, 1, memory);
      actors = Collections.singletonList(story.getActor());
      this.eventualAction = ConstantConditions.notNull("eventualAction", eventualAction);
    }

    @Override
    void endAction() throws Exception {
      Setting.set(getSetting());
      try {
        eventualAction.run();

      } finally {
        Setting.unset();
      }
    }

    @NotNull
    List<Actor> getInputActors() {
      return actors;
    }
  }

  private static class EvolverConditionHandler
      implements NullaryFunction<Event<? extends Boolean>> {

    private final StoryEvolver<?, ?> storyEvolver;

    EvolverConditionHandler(@NotNull final StoryEvolver<?, ?> storyEvolver) {
      this.storyEvolver = ConstantConditions.notNull("storyEvolver", storyEvolver);
    }

    public Event<? extends Boolean> call() throws Exception {
      return storyEvolver.canContinue();
    }
  }

  private static class EvolverEffectHandler<T, R> implements UnaryFunction<T, Story<R>> {

    private final StoryEvolver<? super T, ? extends R> storyEvolver;

    EvolverEffectHandler(@NotNull final StoryEvolver<? super T, ? extends R> storyEvolver) {
      this.storyEvolver = ConstantConditions.notNull("storyEvolver", storyEvolver);
    }

    @SuppressWarnings("unchecked")
    public Story<R> call(final T effect) throws Exception {
      return (Story<R>) storyEvolver.evolve(effect);
    }
  }

  private static class FunctionStory<T> extends AbstractStory<T> {

    private final NullaryFunction<? extends Story<? extends T>> storyCreator;

    private List<Actor> actors;

    private FunctionStory(@NotNull final NullaryFunction<? extends Story<? extends T>> storyCreator,
        @NotNull final Memory memory) {
      super(INFINITE_LOOP, 1, memory);
      this.storyCreator = ConstantConditions.notNull("storyCreator", storyCreator);
    }

    @NotNull
    List<Actor> getInputActors() {
      if (actors == null) {
        Setting.set(getSetting());
        Story<? extends T> story;
        try {
          story = storyCreator.call();
          if (story == null) {
            story = ofEmpty();
          }

        } catch (final Throwable t) {
          story = ofSingleIncident(t);
          if (t instanceof InterruptedException) {
            Thread.currentThread().interrupt();
          }

        } finally {
          Setting.unset();
        }
        actors = Collections.singletonList(story.getActor());
      }
      return actors;
    }
  }

  private static class GenericStory<T, R> extends AbstractStory<R> {

    private final UnaryFunction<? super List<T>, ? extends Story<? extends R>> effectHandler;
    private final List<Actor> inputActors;

    @SuppressWarnings("ResultOfMethodCallIgnored")
    private GenericStory(@NotNull final Iterable<? extends Story<? extends T>> stories,
        @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
        @NotNull final UnaryFunction<? super List<T>, ? extends Story<? extends R>> effectHandler,
        @NotNull final Memory memory) {
      super(conditionHandler, Iterables.size(stories), memory);
      final ArrayList<Actor> inputActors = new ArrayList<Actor>();
      for (final Story<? extends T> story : stories) {
        inputActors.add(story.getActor());
      }
      ConstantConditions.positive("stories size", inputActors.size());
      this.inputActors = inputActors;
      this.effectHandler = ConstantConditions.notNull("effectHandler", effectHandler);
    }

    @Nullable
    @Override
    @SuppressWarnings("unchecked")
    Actor getOutputActor(@NotNull final Object[] inputs, @NotNull final Agent agent) throws
        Exception {
      Setting.set(getSetting());
      try {
        final ArrayList<T> inputList = new ArrayList<T>();
        for (final Object input : inputs) {
          inputList.add((T) input);
        }
        final Story<? extends R> story = effectHandler.call(inputList);
        if ((story == null) || isEmpty(story)) {
          return null;
        }
        return story.getActor();

      } finally {
        Setting.unset();
      }
    }

    @NotNull
    List<Actor> getInputActors() {
      return inputActors;
    }
  }

  private static class GenericTransformStory<T, R> extends AbstractStory<R> {

    private final UnaryFunction<? super List<T>, ? extends R> effectHandler;
    private final List<Actor> inputActors;

    @SuppressWarnings("ResultOfMethodCallIgnored")
    private GenericTransformStory(@NotNull final Iterable<? extends Story<? extends T>> stories,
        @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
        @NotNull final UnaryFunction<? super List<T>, ? extends R> effectHandler,
        @NotNull final Memory memory) {
      super(conditionHandler, Iterables.size(stories), memory);
      final ArrayList<Actor> inputActors = new ArrayList<Actor>();
      for (final Story<? extends T> story : stories) {
        inputActors.add(story.getActor());
      }
      ConstantConditions.positive("stories size", inputActors.size());
      this.inputActors = inputActors;
      this.effectHandler = ConstantConditions.notNull("effectHandler", effectHandler);
    }

    @Nullable
    @Override
    @SuppressWarnings("unchecked")
    Actor getOutputActor(@NotNull final Object[] inputs, @NotNull final Agent agent) throws
        Exception {
      Setting.set(getSetting());
      try {
        final ArrayList<T> inputList = new ArrayList<T>();
        for (final Object input : inputs) {
          inputList.add((T) input);
        }
        final R effect = effectHandler.call(inputList);
        putEffect(effect, agent);
        return null;

      } finally {
        Setting.unset();
      }
    }

    @NotNull
    List<Actor> getInputActors() {
      return inputActors;
    }
  }

  private static class IncidentStory<T> extends Story<T> {

    private final Actor actor;

    private IncidentStory(@NotNull final Throwable incident) {
      final Conflict conflict = new Conflict(incident);
      actor = Stage.newActor(new LocalPlotRole(Setting.get()) {

        private final HashSet<String> threadIds = new HashSet<String>();

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new AbstractBehavior() {

            public void onMessage(final Object message, @NotNull final Envelop envelop,
                @NotNull final Agent agent) {
              if (message == GET) {
                envelop.getSender()
                    .tell(conflict, envelop.getHeaders().threadOnly(), agent.getSelf());

              } else if (message == NEXT) {
                final HashSet<String> threads = threadIds;
                final Headers headers = envelop.getHeaders().threadOnly();
                final String threadId = headers.getThreadId();
                if (!threads.contains(threadId)) {
                  envelop.getSender().tell(conflict, headers, agent.getSelf());
                  threads.add(threadId);

                } else {
                  envelop.getSender()
                      .tell(END, envelop.getHeaders().threadOnly(), agent.getSelf());
                }

              } else if (message == BREAK) {
                threadIds.remove(envelop.getHeaders().getThreadId());
              }
              envelop.preventReceipt();
            }
          };
        }
      });
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class IncidentsStory<T> extends Story<T> {

    private final Actor actor;

    private IncidentsStory(@NotNull final Iterable<? extends Throwable> incidents) {
      ConstantConditions.notNull("incidents", incidents);
      actor = Stage.newActor(new LocalPlotRole(Setting.get()) {

        private final HashMap<String, Iterator<? extends Throwable>> threadIds =
            new HashMap<String, Iterator<? extends Throwable>>();

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new AbstractBehavior() {

            public void onMessage(final Object message, @NotNull final Envelop envelop,
                @NotNull final Agent agent) {
              if (message == GET) {
                envelop.getSender()
                    .tell(new Conflict(Iterables.first(incidents)),
                        envelop.getHeaders().threadOnly(), agent.getSelf());

              } else if (message == NEXT) {
                final HashMap<String, Iterator<? extends Throwable>> threads = threadIds;
                final Headers headers = envelop.getHeaders().threadOnly();
                final String threadId = headers.getThreadId();
                Iterator<? extends Throwable> iterator = threads.get(threadId);
                if (iterator == null) {
                  iterator = incidents.iterator();
                  threads.put(threadId, iterator);
                }
                envelop.getSender()
                    .tell(iterator.hasNext() ? new Conflict(iterator.next()) : END, headers,
                        agent.getSelf());

              } else if (message == BREAK) {
                threadIds.remove(envelop.getHeaders().getThreadId());
              }
              envelop.preventReceipt();
            }
          };
        }
      });
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class JoinStory<T, R> extends Story<R> {

    private final Actor actor;
    private final UnaryFunction<? super T, ? extends Event<? extends R>> effectHandler;
    private final HashMap<String, Sender> getSenders = new HashMap<String, Sender>();
    private final Actor inputActor;
    private final Headers inputHeaders;
    private final int maxConcurrency;
    private final int maxEventWindow;
    private final Memory memory;
    private final HashMap<String, SenderIterator> nextSenders =
        new HashMap<String, SenderIterator>();
    private final Headers headers;
    private final LinkedHashMap<Actor, OutputEffect> outputEffects =
        new LinkedHashMap<Actor, OutputEffect>();
    private final String outputThread;
    private final Setting setting;

    private int actorCount;
    private Conflict inputConflict;
    private boolean inputsEnded;
    private boolean inputsPending;
    private long outputCount;

    private JoinStory(@NotNull final Story<? extends T> story, final int maxConcurrency,
        final int maxEventWindow,
        @NotNull final UnaryFunction<? super T, ? extends Event<? extends R>> effectHandler,
        @NotNull final Memory memory) {
      inputActor = story.getActor();
      this.maxConcurrency = ConstantConditions.positive("maxConcurrency", maxConcurrency);
      this.maxEventWindow = ConstantConditions.positive("maxEventWindow", maxEventWindow);
      this.effectHandler = ConstantConditions.notNull("effectHandler", effectHandler);
      this.memory = ConstantConditions.notNull("memory", memory);
      final Setting setting = (this.setting = Setting.get());
      final String actorId = (actor = Stage.newActor(new PlotRole(setting) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new InitBehavior();
        }
      })).getId();
      final Headers headers = (this.headers = new Headers().withReceiptId(actorId));
      outputThread = actorId + ":output";
      inputHeaders = headers.withThreadId(actorId + ":input");
    }

    private void done(@NotNull final Agent agent) {
      done(memory, getSenders, nextSenders, agent);
    }

    private void fail(@NotNull final Conflict conflict, @NotNull final Agent agent) {
      fail(conflict, memory, getSenders, nextSenders, agent);
    }

    @NotNull
    @SuppressWarnings("unchecked")
    private Actor getOutputActor(@NotNull final Object input) throws Exception {
      Setting.set(setting);
      try {
        final Event<? extends R> event = effectHandler.call((T) input);
        return ((event != null) ? event : Event.ofNull()).getActor();

      } finally {
        Setting.unset();
      }
    }

    private class CancelBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = JoinStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          sender.tellNext(agent.getSelf());

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else {
          final Headers inputHeaders = JoinStory.this.inputHeaders;
          if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            inputActor.tell(BREAK, inputHeaders, agent.getSelf());
            inputsEnded = true;
            if (actorCount == 0) {
              fail(Conflict.ofCancel(), agent);
            }

          } else {
            final String threadId = envelop.getHeaders().getThreadId();
            if ((threadId != null) && threadId.startsWith(outputThread)) {
              final Actor sender = envelop.getSender();
              sender.tell(BREAK, outputEffects.get(sender).getHeaders(), agent.getSelf());
              if ((--actorCount == 0) && inputsEnded) {
                fail(Conflict.ofCancel(), agent);
              }
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    private class InitBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
          inputActor.tell(NEXT, inputHeaders, agent.getSelf());
          agent.setBehavior(new InputBehavior());

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders().threadOnly();
          final SenderIterator sender = new SenderIterator(envelop.getSender(), headers);
          sender.setIterator(memory.iterator());
          nextSenders.put(headers.getThreadId(), sender);
          inputActor.tell(NEXT, inputHeaders, agent.getSelf());
          agent.setBehavior(new InputBehavior());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class InputBehavior extends AbstractBehavior {

      public void onMessage(Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = JoinStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          agent.setBehavior(new CancelBehavior());

        } else {
          final Headers inputHeaders = JoinStory.this.inputHeaders;
          if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            if (message == END) {
              inputActor.tell(BREAK, inputHeaders, agent.getSelf());
              done(agent);

            } else if (message instanceof Conflict) {
              inputActor.tell(BREAK, inputHeaders, agent.getSelf());
              fail((Conflict) message, agent);

            } else if (message instanceof Bounce) {
              fail(Conflict.ofBounce((Bounce) message), agent);

            } else {
              try {
                final Actor outputActor = getOutputActor(message);
                final String outputThreadId = outputThread + "#" + outputCount++;
                final Headers headers = JoinStory.this.headers.withThreadId(outputThreadId);
                final LinkedHashMap<Actor, OutputEffect> outputEffects =
                    JoinStory.this.outputEffects;
                outputEffects.put(outputActor, new OutputEffect(headers));
                outputActor.tell(GET, headers, agent.getSelf());
                if ((inputsPending = (++actorCount < maxConcurrency) && (outputEffects.size()
                    < maxEventWindow))) {
                  inputActor.tell(NEXT, inputHeaders, agent.getSelf());
                }
                agent.setBehavior(new OutputBehavior());

              } catch (final Throwable t) {
                inputActor.tell(BREAK, inputHeaders, agent.getSelf());
                fail(new Conflict(t), agent);
                if (t instanceof InterruptedException) {
                  Thread.currentThread().interrupt();
                }
              }
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    private class OutputBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = JoinStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          sender.tellNext(agent.getSelf());

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          final Actor self = agent.getSelf();
          for (final Entry<Actor, OutputEffect> entry : outputEffects.entrySet()) {
            final OutputEffect outputEffect = entry.getValue();
            if (!outputEffect.isSet()) {
              entry.getKey().tell(CANCEL, null, self);
            }
          }
          inputActor.tell(CANCEL, null, self);
          agent.setBehavior(new CancelBehavior());

        } else {
          final Headers inputHeaders = JoinStory.this.inputHeaders;
          if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            if (message == END) {
              inputActor.tell(BREAK, inputHeaders, agent.getSelf());
              inputsEnded = true;
              if (actorCount == 0) {
                done(agent);
              }

            } else if (message instanceof Conflict) {
              inputActor.tell(BREAK, inputHeaders, agent.getSelf());
              inputsEnded = true;
              final Conflict conflict = (inputConflict = (Conflict) message);
              if (actorCount == 0) {
                fail(conflict, agent);
              }

            } else if (message instanceof Bounce) {
              inputsEnded = true;
              final Conflict conflict = (inputConflict = Conflict.ofBounce((Bounce) message));
              if (actorCount == 0) {
                fail(conflict, agent);
              }

            } else {
              try {
                final Actor outputActor = getOutputActor(message);
                final String outputThreadId = outputThread + "#" + outputCount++;
                final Headers headers = JoinStory.this.headers.withThreadId(outputThreadId);
                final LinkedHashMap<Actor, OutputEffect> outputEffects =
                    JoinStory.this.outputEffects;
                outputEffects.put(outputActor, new OutputEffect(headers));
                outputActor.tell(GET, headers, agent.getSelf());
                if ((inputsPending = (++actorCount < maxConcurrency) && (outputEffects.size()
                    < maxEventWindow))) {
                  inputActor.tell(NEXT, inputHeaders, agent.getSelf());
                }

              } catch (final Throwable t) {
                inputsEnded = true;
                final Conflict conflict = (inputConflict = new Conflict(t));
                if (actorCount == 0) {
                  fail(conflict, agent);
                }

                if (t instanceof InterruptedException) {
                  Thread.currentThread().interrupt();
                }
              }
            }

          } else {
            final String threadId = envelop.getHeaders().getThreadId();
            if ((threadId != null) && threadId.startsWith(outputThread)) {
              final Object effect;
              if (message instanceof Bounce) {
                effect = Conflict.ofBounce((Bounce) message);

              } else {
                effect = message;
              }
              // pass on conflicts
              final Memory memory = JoinStory.this.memory;
              final LinkedHashMap<Actor, OutputEffect> outputEffects = JoinStory.this.outputEffects;
              outputEffects.get(envelop.getSender()).set(effect);
              final Iterator<OutputEffect> iterator = outputEffects.values().iterator();
              while (iterator.hasNext()) {
                final OutputEffect outputEffect = iterator.next();
                if (outputEffect.isSet()) {
                  memory.put(outputEffect.getEffect());
                  iterator.remove();

                } else {
                  break;
                }
              }
              final Actor self = agent.getSelf();
              for (final SenderIterator sender : nextSenders.values()) {
                sender.tellNext(self);
              }

              if (outputEffects.size() < maxEventWindow) {
                if (!inputsEnded) {
                  if (!inputsPending) {
                    inputsPending = true;
                    inputActor.tell(NEXT, inputHeaders, self);
                  }

                } else if (--actorCount == 0) {
                  final Conflict conflict = inputConflict;
                  if (conflict != null) {
                    fail(conflict, agent);

                  } else {
                    done(agent);
                  }
                }
              }
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class NullaryStory<T> extends AbstractStory<T> {

    private final List<Actor> inputActors;

    private NullaryStory(@NotNull final Story<? extends T> firstStory,
        @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
        @NotNull final Memory memory) {
      super(conditionHandler, 1, memory);
      inputActors = Collections.singletonList(firstStory.getActor());
    }

    @NotNull
    List<Actor> getInputActors() {
      return inputActors;
    }
  }

  private static class OutputEffect {

    private final Headers headers;

    private Object effect;
    private boolean isSet;

    private OutputEffect(@NotNull final Headers headers) {
      this.headers = headers;
    }

    Object getEffect() {
      return effect;
    }

    @NotNull
    Headers getHeaders() {
      return headers;
    }

    boolean isSet() {
      return isSet;
    }

    void set(final Object effect) {
      isSet = true;
      this.effect = effect;
    }
  }

  private static class ResolveStory<T> extends AbstractStory<T> {

    private final UnaryFunction<? super Throwable, ? extends Story<T>> incidentHandler;
    private final Set<Class<? extends Throwable>> incidentTypes;
    private final List<Actor> inputActors;

    @SuppressWarnings("ResultOfMethodCallIgnored")
    private ResolveStory(@NotNull final Story<? extends T> story,
        @NotNull final Set<Class<? extends Throwable>> incidentTypes,
        @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
        @NotNull final UnaryFunction<? super Throwable, ? extends Story<T>> incidentHandler,
        @NotNull final Memory memory) {
      super(conditionHandler, 1, memory);
      inputActors = Collections.singletonList(story.getActor());
      ConstantConditions.positive("incidentTypes size", incidentTypes.size());
      this.incidentTypes = ConstantConditions.notNullElements("incidentTypes", incidentTypes);
      this.incidentHandler = ConstantConditions.notNull("incidentHandler", incidentHandler);
    }

    @Nullable
    @Override
    Actor getConflictActor(@NotNull final Conflict conflict, @NotNull final Agent agent) throws
        Exception {
      final Throwable incident = conflict.getCause();
      for (final Class<? extends Throwable> incidentType : incidentTypes) {
        if (incidentType.isInstance(incident)) {
          Setting.set(getSetting());
          try {
            final Story<T> story = incidentHandler.call(incident);
            return ((story != null) ? story : ofEmpty()).getActor();

          } finally {
            Setting.unset();
          }
        }
      }
      return super.getConflictActor(conflict, agent);
    }

    @NotNull
    List<Actor> getInputActors() {
      return inputActors;
    }
  }

  private static class ResolveTransformStory<T> extends AbstractStory<T> {

    private final UnaryFunction<? super Throwable, ? extends T> incidentHandler;
    private final Set<Class<? extends Throwable>> incidentTypes;
    private final List<Actor> inputActors;

    @SuppressWarnings("ResultOfMethodCallIgnored")
    private ResolveTransformStory(@NotNull final Story<? extends T> story,
        @NotNull final Set<Class<? extends Throwable>> incidentTypes,
        @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
        @NotNull final UnaryFunction<? super Throwable, ? extends T> incidentHandler,
        @NotNull final Memory memory) {
      super(conditionHandler, 1, memory);
      inputActors = Collections.singletonList(story.getActor());
      ConstantConditions.positive("incidentTypes size", incidentTypes.size());
      this.incidentTypes = ConstantConditions.notNullElements("incidentTypes", incidentTypes);
      this.incidentHandler = ConstantConditions.notNull("incidentHandler", incidentHandler);
    }

    @Nullable
    @Override
    Actor getConflictActor(@NotNull final Conflict conflict, @NotNull final Agent agent) throws
        Exception {
      final Throwable incident = conflict.getCause();
      for (final Class<? extends Throwable> incidentType : incidentTypes) {
        if (incidentType.isInstance(incident)) {
          Setting.set(getSetting());
          try {
            final T effect = incidentHandler.call(incident);
            putEffect(effect, agent);
            return null;

          } finally {
            Setting.unset();
          }
        }
      }
      return super.getConflictActor(conflict, agent);
    }

    @NotNull
    List<Actor> getInputActors() {
      return inputActors;
    }
  }

  private static class ScheduleAtFixedRateStory<T> extends Story<T> implements Runnable {

    private final Actor actor;
    private final HashMap<String, Sender> getSenders = new HashMap<String, Sender>();
    private final long initialDelay;
    private final Actor inputActor;
    private final Headers inputHeaders;
    private final Memory memory;
    private final HashMap<String, SenderIterator> nextSenders =
        new HashMap<String, SenderIterator>();
    private final long period;
    private final TimeUnit unit;

    private boolean inputsPending;
    private ScheduledFuture<?> scheduledFuture;

    private ScheduleAtFixedRateStory(@NotNull final Story<? extends T> story,
        final long initialDelay, final long period, @NotNull final TimeUnit unit,
        @NotNull final Memory memory) {
      inputActor = story.getActor();
      this.initialDelay = Math.max(initialDelay, 0);
      this.period = ConstantConditions.positive("period", period);
      this.unit = ConstantConditions.notNull("unit", unit);
      this.memory = ConstantConditions.notNull("memory", memory);
      final String actorId = (actor = Stage.newActor(new PlotRole(Setting.get()) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new InitBehavior();
        }
      })).getId();
      inputHeaders = new Headers().withReceiptId(actorId).withThreadId(actorId + ":input");
    }

    public void run() {
      inputsPending = true;
      inputActor.tell(NEXT, inputHeaders, actor);
    }

    private void done(@NotNull final Agent agent) {
      final ScheduledFuture<?> scheduledFuture = this.scheduledFuture;
      if (scheduledFuture != null) {
        scheduledFuture.cancel(false);
      }
      done(memory, getSenders, nextSenders, agent);
    }

    private void fail(@NotNull final Conflict conflict, @NotNull final Agent agent) {
      final ScheduledFuture<?> scheduledFuture = this.scheduledFuture;
      if (scheduledFuture != null) {
        scheduledFuture.cancel(false);
      }
      fail(conflict, memory, getSenders, nextSenders, agent);
    }

    private class CancelBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders =
              ScheduleAtFixedRateStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          sender.tellNext(agent.getSelf());

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else {
          final Headers inputHeaders = ScheduleAtFixedRateStory.this.inputHeaders;
          if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            inputActor.tell(BREAK, inputHeaders, agent.getSelf());
            fail(Conflict.ofCancel(), agent);
          }
        }
        envelop.preventReceipt();
      }
    }

    private class InitBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
          scheduledFuture = agent.getScheduledExecutorService()
              .scheduleAtFixedRate(ScheduleAtFixedRateStory.this, initialDelay, period, unit);
          agent.setBehavior(new InputBehavior());

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders().threadOnly();
          final SenderIterator sender = new SenderIterator(envelop.getSender(), headers);
          sender.setIterator(memory.iterator());
          nextSenders.put(headers.getThreadId(), sender);
          scheduledFuture = agent.getScheduledExecutorService()
              .scheduleAtFixedRate(ScheduleAtFixedRateStory.this, initialDelay, period, unit);
          agent.setBehavior(new InputBehavior());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class InputBehavior extends AbstractBehavior {

      public void onMessage(Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders =
              ScheduleAtFixedRateStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          sender.tellNext(agent.getSelf());

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          if (inputsPending) {
            agent.setBehavior(new CancelBehavior());

          } else {
            fail(Conflict.ofCancel(), agent);
          }

        } else {
          final Headers inputHeaders = ScheduleAtFixedRateStory.this.inputHeaders;
          if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            if (message == END) {
              inputActor.tell(BREAK, inputHeaders, agent.getSelf());
              done(agent);

            } else if (message instanceof Conflict) {
              inputActor.tell(BREAK, inputHeaders, agent.getSelf());
              fail((Conflict) message, agent);

            } else if (message instanceof Bounce) {
              fail(Conflict.ofBounce((Bounce) message), agent);

            } else {
              memory.put(message);
              final Actor self = agent.getSelf();
              for (final SenderIterator sender : nextSenders.values()) {
                sender.tellNext(self);
              }
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class ScheduleWithFixedDelayStory<T> extends Story<T> implements Runnable {

    private final Actor actor;
    private final long delay;
    private final HashMap<String, Sender> getSenders = new HashMap<String, Sender>();
    private final long initialDelay;
    private final Actor inputActor;
    private final Headers inputHeaders;
    private final Memory memory;
    private final HashMap<String, SenderIterator> nextSenders =
        new HashMap<String, SenderIterator>();
    private final TimeUnit unit;

    private boolean inputsPending;
    private ScheduledFuture<?> scheduledFuture;

    private ScheduleWithFixedDelayStory(@NotNull final Story<? extends T> story,
        final long initialDelay, final long delay, @NotNull final TimeUnit unit,
        @NotNull final Memory memory) {
      inputActor = story.getActor();
      this.initialDelay = Math.max(initialDelay, 0);
      this.delay = ConstantConditions.positive("delay", delay);
      this.unit = ConstantConditions.notNull("unit", unit);
      this.memory = ConstantConditions.notNull("memory", memory);
      final String actorId = (actor = Stage.newActor(new PlotRole(Setting.get()) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new InitBehavior();
        }
      })).getId();
      inputHeaders = new Headers().withReceiptId(actorId).withThreadId(actorId + ":input");
    }

    private void done(@NotNull final Agent agent) {
      final ScheduledFuture<?> scheduledFuture = this.scheduledFuture;
      if (scheduledFuture != null) {
        scheduledFuture.cancel(false);
      }
      done(memory, getSenders, nextSenders, agent);
    }

    private void fail(@NotNull final Conflict conflict, @NotNull final Agent agent) {
      final ScheduledFuture<?> scheduledFuture = this.scheduledFuture;
      if (scheduledFuture != null) {
        scheduledFuture.cancel(false);
      }
      fail(conflict, memory, getSenders, nextSenders, agent);
    }

    private class CancelBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders =
              ScheduleWithFixedDelayStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          sender.tellNext(agent.getSelf());

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else {
          final Headers inputHeaders = ScheduleWithFixedDelayStory.this.inputHeaders;
          if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            inputActor.tell(BREAK, inputHeaders, agent.getSelf());
            fail(Conflict.ofCancel(), agent);
          }
        }
        envelop.preventReceipt();
      }
    }

    private class InitBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
          scheduledFuture = agent.getScheduledExecutorService()
              .schedule(ScheduleWithFixedDelayStory.this, initialDelay, unit);
          agent.setBehavior(new InputBehavior());

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders().threadOnly();
          final SenderIterator sender = new SenderIterator(envelop.getSender(), headers);
          sender.setIterator(memory.iterator());
          nextSenders.put(headers.getThreadId(), sender);
          scheduledFuture = agent.getScheduledExecutorService()
              .schedule(ScheduleWithFixedDelayStory.this, initialDelay, unit);
          agent.setBehavior(new InputBehavior());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class InputBehavior extends AbstractBehavior {

      public void onMessage(Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders =
              ScheduleWithFixedDelayStory.this.nextSenders;
          SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            sender = new SenderIterator(envelop.getSender(), headers.threadOnly());
            sender.setIterator(memory.iterator());
            nextSenders.put(threadId, sender);
          }
          sender.tellNext(agent.getSelf());

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          if (inputsPending) {
            agent.setBehavior(new CancelBehavior());

          } else {
            fail(Conflict.ofCancel(), agent);
          }

        } else {
          final Headers inputHeaders = ScheduleWithFixedDelayStory.this.inputHeaders;
          if (isSame(inputHeaders.getThreadId(), envelop.getHeaders().getThreadId())) {
            if (message == END) {
              inputActor.tell(BREAK, inputHeaders, agent.getSelf());
              done(agent);

            } else if (message instanceof Conflict) {
              inputActor.tell(BREAK, inputHeaders, agent.getSelf());
              fail((Conflict) message, agent);

            } else if (message instanceof Bounce) {
              fail(Conflict.ofBounce((Bounce) message), agent);

            } else {
              memory.put(message);
              final Actor self = agent.getSelf();
              for (final SenderIterator sender : nextSenders.values()) {
                sender.tellNext(self);
              }
              scheduledFuture = agent.getScheduledExecutorService()
                  .schedule(ScheduleWithFixedDelayStory.this, delay, unit);
            }
          }
        }
        envelop.preventReceipt();
      }
    }

    public void run() {
      inputsPending = true;
      inputActor.tell(NEXT, inputHeaders, actor);
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class Sender {

    private final Headers headers;
    private final Actor sender;

    private Sender(@NotNull final Actor sender, @NotNull final Headers headers) {
      this.sender = sender;
      this.headers = headers;
    }

    @NotNull
    Headers getHeaders() {
      return headers;
    }

    @NotNull
    Actor getSender() {
      return sender;
    }
  }

  private static class SenderIterator extends Sender {

    private Iterator<?> iterator;
    private boolean waitNext = true;

    private SenderIterator(@NotNull final Actor sender, @NotNull final Headers headers) {
      super(sender, headers);
    }

    boolean isWaitNext() {
      return waitNext;
    }

    void setIterator(@NotNull final Iterator<?> iterator) {
      this.iterator = iterator;
    }

    boolean tellNext(@NotNull final Actor self) {
      final Iterator<?> iterator = this.iterator;
      if (waitNext && iterator.hasNext()) {
        waitNext = false;
        getSender().tell(iterator.next(), getHeaders(), self);
        return true;
      }
      return false;
    }

    void waitNext() {
      waitNext = true;
    }
  }

  private static class StoryObserverRole<T> extends Role {

    private final Actor storyActor;
    private final StoryObserver<? super T> storyObserver;

    private StoryObserverRole(@NotNull final Actor storyActor,
        @NotNull final StoryObserver<? super T> storyObserver) {
      this.storyActor = ConstantConditions.notNull("storyActor", storyActor);
      this.storyObserver = ConstantConditions.notNull("storyObserver", storyObserver);
    }

    @NotNull
    public Behavior getBehavior(@NotNull final String id) {
      final Headers headers = new Headers().withReceiptId(id).withThreadId(id);
      return new AbstractBehavior() {

        private final ArrayList<Object> effects = new ArrayList<Object>();

        private boolean isPaused;

        @SuppressWarnings("unchecked")
        public void onMessage(final Object message, @NotNull final Envelop envelop,
            @NotNull final Agent agent) throws Exception {
          final Actor self = agent.getSelf();
          if (message instanceof Conflict) {
            if (isPaused) {
              effects.add(message);

            } else {
              storyObserver.onIncident(((Conflict) message).getCause());
              envelop.getSender().tell(Story.NEXT, headers, self);
            }

          } else if (message instanceof Bounce) {
            if (isPaused) {
              final ArrayList<Object> effects = this.effects;
              effects.add(new Conflict(PlotFailureException.getOrNew((Bounce) message)));
              effects.add(Story.END);

            } else {
              storyObserver.onIncident(PlotFailureException.getOrNew((Bounce) message));
              agent.dismissSelf();
            }

          } else if (message == Story.END) {
            if (isPaused) {
              effects.add(Story.END);

            } else {
              storyObserver.onEnd();
              agent.dismissSelf();
            }

          } else if (message == Spectator.PAUSE) {
            isPaused = true;

          } else if ((message == Spectator.RESUME) && isPaused) {
            final StoryObserver<? super T> storyObserver = StoryObserverRole.this.storyObserver;
            final ArrayList<Object> effects = this.effects;
            boolean isEnded = false;
            for (final Object effect : effects) {
              if (effect instanceof Conflict) {
                storyObserver.onIncident(((Conflict) effect).getCause());

              } else if (effect == Story.END) {
                storyObserver.onEnd();
                isEnded = true;

              } else {
                storyObserver.onEffect((T) message);
              }
            }

            if (isEnded) {
              agent.dismissSelf();

            } else {
              isPaused = false;
              effects.clear();
              envelop.getSender().tell(Story.NEXT, headers, self);
            }

          } else if (message == Spectator.CANCEL) {
            storyActor.tell(Story.CANCEL, headers, self);

          } else if (message == Spectator.CANCEL_AND_DISMISS) {
            storyActor.tell(Story.CANCEL, headers, self);
            agent.dismissSelf();

          } else if (!(message instanceof Receipt)) {
            if (isPaused) {
              effects.add(message);

            } else {
              storyObserver.onEffect((T) message);
              envelop.getSender().tell(Story.NEXT, headers, self);
            }
          }
        }

        @Override
        public void onStop(@NotNull final Agent agent) {
          storyActor.tell(Story.BREAK, headers, agent.getSelf());
        }
      };
    }

    @NotNull
    @Override
    public ExecutorService getExecutorService(@NotNull final String id) {
      return ExecutorServices.localExecutor();
    }
  }
{{#arities}}

  private static class {{classPrefix}}Story<{{#paramTypes}}{{type}}, {{/paramTypes}}R> extends AbstractStory<R> {

    private final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Story<? extends R>> effectHandler;
    private final List<Actor> inputActors;

    @SuppressWarnings("ArraysAsListWithZeroOrOneArgument")
    private {{classPrefix}}Story({{#paramTypes}}@NotNull final Story<? extends {{type}}> {{prefix}}Story, {{/paramTypes}}
        @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
        @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends Story<? extends R>> effectHandler,
        @NotNull final Memory memory) {
      super(conditionHandler, {{paramNum}}, memory);
      inputActors = Arrays.asList({{#paramTypes}}{{prefix}}Story.getActor(){{#hasNext}}, {{/hasNext}}{{/paramTypes}});
      this.effectHandler = ConstantConditions.notNull("effectHandler", effectHandler);
    }

    @Nullable
    @Override
    @SuppressWarnings("unchecked")
    Actor getOutputActor(@NotNull final Object[] inputs, @NotNull final Agent agent) throws
        Exception {
      Setting.set(getSetting());
      try {
        final Story<? extends R> story = effectHandler.call({{#paramTypes}}({{type}}) inputs[{{index}}]{{#hasNext}}, {{/hasNext}}{{/paramTypes}});
        if ((story == null) || isEmpty(story)) {
          return null;
        }
        return story.getActor();

      } finally {
        Setting.unset();
      }
    }

    @NotNull
    List<Actor> getInputActors() {
      return inputActors;
    }
  }

  private static class {{classPrefix}}TransformStory<{{#paramTypes}}{{type}}, {{/paramTypes}}R> extends AbstractStory<R> {

    private final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends R> effectHandler;
    private final List<Actor> inputActors;

    @SuppressWarnings("ArraysAsListWithZeroOrOneArgument")
    private {{classPrefix}}TransformStory({{#paramTypes}}@NotNull final Story<? extends {{type}}> {{prefix}}Story, {{/paramTypes}}
        @NotNull final NullaryFunction<? extends Event<? extends Boolean>> conditionHandler,
        @NotNull final {{classPrefix}}Function<{{#paramTypes}}? super {{type}}, {{/paramTypes}}? extends R> effectHandler,
        @NotNull final Memory memory) {
      super(conditionHandler, {{paramNum}}, memory);
      inputActors = Arrays.asList({{#paramTypes}}{{prefix}}Story.getActor(){{#hasNext}}, {{/hasNext}}{{/paramTypes}});
      this.effectHandler = ConstantConditions.notNull("effectHandler", effectHandler);
    }

    @Nullable
    @Override
    @SuppressWarnings("unchecked")
    Actor getOutputActor(@NotNull final Object[] inputs, @NotNull final Agent agent) throws
        Exception {
      Setting.set(getSetting());
      try {
        final R effect = effectHandler.call({{#paramTypes}}({{type}}) inputs[{{index}}]{{#hasNext}}, {{/hasNext}}{{/paramTypes}});
        putEffect(effect, agent);
        return null;

      } finally {
        Setting.unset();
      }
    }

    @NotNull
    List<Actor> getInputActors() {
      return inputActors;
    }
  }
{{/arities}}

  private static class TransformerConditionHandler
      implements NullaryFunction<Event<? extends Boolean>> {

    private final StoryTransformer<?, ?> storyTransformer;

    TransformerConditionHandler(@NotNull final StoryTransformer<?, ?> storyTransformer) {
      this.storyTransformer = ConstantConditions.notNull("storyTransformer", storyTransformer);
    }

    public Event<? extends Boolean> call() throws Exception {
      return storyTransformer.canContinue();
    }
  }

  private static class TransformerEffectHandler<T, R> implements UnaryFunction<T, R> {

    private final StoryTransformer<? super T, ? extends R> storyTransformer;

    TransformerEffectHandler(
        @NotNull final StoryTransformer<? super T, ? extends R> storyTransformer) {
      this.storyTransformer = ConstantConditions.notNull("storyTransformer", storyTransformer);
    }

    public R call(final T effect) throws Exception {
      return storyTransformer.transform(effect);
    }
  }

  private static class UnfoldStory<T> extends Story<T> {

    private final Actor actor;
    private final HashMap<String, Sender> getSenders = new HashMap<String, Sender>();
    private final Actor inputActor;
    private final Headers inputHeaders;
    private final String inputThreadId;
    private final HashMap<String, SenderIterator> nextSenders =
        new HashMap<String, SenderIterator>();

    private UnfoldStory(@NotNull final Event<? extends Iterable<? extends T>> event) {
      inputActor = event.getActor();
      final String actorId = (actor = Stage.newActor(new LocalPlotRole(Setting.get()) {

        @NotNull
        @Override
        public Behavior getBehavior(@NotNull final String id) {
          return new InitBehavior();
        }
      })).getId();
      inputThreadId = actorId;
      inputHeaders = new Headers().withReceiptId(actorId).withThreadId(actorId);
    }

    private void fail(@NotNull final Conflict conflict, @NotNull final Agent agent) {
      final SingletonMemory memory = new SingletonMemory();
      for (final SenderIterator sender : nextSenders.values()) {
        sender.setIterator(memory.iterator());
      }
      fail(conflict, memory, getSenders, nextSenders, agent);
    }

    private class CancelBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = UnfoldStory.this.nextSenders;
          final SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            nextSenders.put(threadId,
                new SenderIterator(envelop.getSender(), headers.threadOnly()));
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (inputThreadId.equals(envelop.getHeaders().getThreadId())) {
          fail(Conflict.ofCancel(), agent);
        }
      }
    }

    private class InitBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));
          inputActor.tell(GET, inputHeaders, agent.getSelf());
          agent.setBehavior(new InputBehavior());

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders().threadOnly();
          nextSenders.put(headers.getThreadId(), new SenderIterator(envelop.getSender(), headers));
          inputActor.tell(GET, inputHeaders, agent.getSelf());
          agent.setBehavior(new InputBehavior());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          fail(Conflict.ofCancel(), agent);
        }
        envelop.preventReceipt();
      }
    }

    private class InputBehavior extends AbstractBehavior {

      public void onMessage(final Object message, @NotNull final Envelop envelop,
          @NotNull final Agent agent) {
        if (message == GET) {
          final Headers headers = envelop.getHeaders().threadOnly();
          getSenders.put(headers.getThreadId(), new Sender(envelop.getSender(), headers));

        } else if (message == NEXT) {
          final Headers headers = envelop.getHeaders();
          final String threadId = headers.getThreadId();
          final HashMap<String, SenderIterator> nextSenders = UnfoldStory.this.nextSenders;
          final SenderIterator sender = nextSenders.get(threadId);
          if (sender != null) {
            sender.waitNext();

          } else {
            nextSenders.put(threadId,
                new SenderIterator(envelop.getSender(), headers.threadOnly()));
          }

        } else if (message == BREAK) {
          nextSenders.remove(envelop.getHeaders().getThreadId());

        } else if (message == CANCEL) {
          inputActor.tell(CANCEL, null, agent.getSelf());
          agent.setBehavior(new CancelBehavior());

        } else if (inputThreadId.equals(envelop.getHeaders().getThreadId())) {
          if (message instanceof Conflict) {
            fail((Conflict) message, agent);

          } else if (message instanceof Bounce) {
            fail(Conflict.ofBounce((Bounce) message), agent);

          } else {
            final Actor self = agent.getSelf();
            final Iterable<?> effects = (Iterable<?>) message;
            for (final Sender sender : getSenders.values()) {
              sender.getSender().tell(effects, sender.getHeaders(), self);
            }

            for (final SenderIterator sender : nextSenders.values()) {
              sender.setIterator(effects.iterator());
              sender.tellNext(self);
            }
            agent.setBehavior(new DoneBehavior(effects, effects, nextSenders));
          }
        }
        envelop.preventReceipt();
      }
    }

    @NotNull
    Actor getActor() {
      return actor;
    }
  }

  private static class WatchAllFunction<T> implements UnaryFunction<T, T> {

    private final Observer<? super T> effectObserver;

    private WatchAllFunction(@Nullable final Observer<? super T> effectObserver) {
      this.effectObserver = ConstantConditions.notNull("effectObserver", effectObserver);
    }

    public T call(final T effect) throws Exception {
      effectObserver.accept(effect);
      return effect;
    }
  }

  private static class WatchStory<T> extends AbstractStory<T> {

    private final EventObserver<? super T> eventObserver;
    private final List<Actor> inputActors;

    private WatchStory(@NotNull final Story<? extends T> story,
        @NotNull final EventObserver<? super T> eventObserver, @NotNull final Memory memory) {
      super(INFINITE_LOOP, 1, memory);
      inputActors = Collections.singletonList(story.getActor());
      this.eventObserver = ConstantConditions.notNull("eventObserver", eventObserver);
    }

    @Nullable
    @Override
    Actor getConflictActor(@NotNull final Conflict conflict, @NotNull final Agent agent) throws
        Exception {
      Setting.set(getSetting());
      try {
        eventObserver.onIncident(conflict.getCause());

      } finally {
        Setting.unset();
      }
      return super.getConflictActor(conflict, agent);
    }

    @Nullable
    @Override
    @SuppressWarnings("unchecked")
    Actor getOutputActor(@NotNull final Object[] inputs, @NotNull final Agent agent) throws
        Exception {
      Setting.set(getSetting());
      try {
        eventObserver.onEffect((T) inputs[0]);

      } finally {
        Setting.unset();
      }
      return super.getOutputActor(inputs, agent);
    }

    @NotNull
    List<Actor> getInputActors() {
      return inputActors;
    }
  }
}
