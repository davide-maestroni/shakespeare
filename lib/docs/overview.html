<!--
  ~ Copyright 2019 Davide Maestroni
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->
<html>
<head>
    <title>shakespeare-lib</title>
</head>
<body>
<a href="https://github.com/davide-maestroni/shakespeare" target="_blank"></a>
<h1>Overview</h1>
<p>
    The core module of the shakespeare library provides a lightweight implementation of an <a
        href="https://en.wikipedia.org/wiki/Actor_model">actor model</a>.<br>
    The main concepts present in this module are:
    <ul>
        <li>
            <a href="http://davide-maestroni.github.io/shakespeare/javadoc/1.0.0/lib/com/github/dm/shakespeare/actor/Actor.html">Actor</a>
<p>
    Interface defining an Actor.<br>
    An Actor represent a processing unit inside the framework. The only way to communicate with it
    is through messages (that is, any Java object).<br>
    A message might be customized through a few pre-defined headers, including a message thread, a
    timestamp offset and an optional receipt ID.
</p>
</li>
<li>
    <a href="http://davide-maestroni.github.io/shakespeare/javadoc/1.0.0/lib/com/github/dm/shakespeare/actor/Behavior.html">Behavior</a>
    <p>
        Interface representing an Actor behavior that defines how the Actor reacts to newly received
        messages and start/stop events.<br>
        The library is designed so that the Behavior source code is executed sequentially, in such a
        way that no other synchronization mechanism is needed at runtime.<br>
        A Behavior instance may represent a single state in a more complex state machine. In fact,
        it can be safely replaced at any moment during an Actor lifecycle.<br>
        Inside a Behavior it is also possible to create new Actor instances, and dismiss them when
        needed.
    </p>
</li>
<li>
    <a href="http://davide-maestroni.github.io/shakespeare/javadoc/1.0.0/lib/com/github/dm/shakespeare/actor/Behavior.Agent.html">Agent</a>
    <p>
        Interface defining an Actor execution environment.<br>
        An Agent provides to the Behavior instance information about the Actor state and several
        ways to control it.<br>
        Moreover, an Agent exposes references to utility classes such as a Logger instance
        and executor services. The services can be safely employed to submit asynchronous tasks,
        since executed they are executed through the same actor synchronization mechanism. Any
        task still pending during the actor dismissal is automatically cancelled by the Agent.
    </p>
</li>
<li>
    <a href="http://davide-maestroni.github.io/shakespeare/javadoc/1.0.0/lib/com/github/dm/shakespeare/actor/Role.html">Role</a>
    <p>
        Base class defining an Actor role.<br>
        A Role provides the needed configuration to set up the newly created Actor instance and its
        initial Behavior.
    </p>
</li>
<li>
    <a href="http://davide-maestroni.github.io/shakespeare/javadoc/1.0.0/lib/com/github/dm/shakespeare/Stage.html">Stage</a>
    <p>
        Base class defining a container of Actors.<br>
        A Stage enables retrieval and filtering of Actors based on their IDs.
    </p>
</li>
</ul>
</p>
<h1>Tutorial (How to)</h1>
<h2>Create a new Stage</h2>
<p>
    A new Stage instance can be simply instantiated through the default constructor.
<pre class="brush:java">
Stage stage = new Stage();
</pre>
</p>
<p>
    Alternatively, in case the actor instance does not need to be retained for future querying, it
    is possible to employ the back stage instance instead.
<pre class="brush:java">
Stage stage = Stage.back();
</pre>
</p>
<p>
    It is also possible to customize actor instantiation by overriding the
    <i class="brush:java">buildActor(String, Role)</i> method.<br>
    For example, to make all the created actors supervised, a new Stage class may be defined as
    follows:
<pre class="brush:java">
public class SupervisedStage extends Stage {

  &#64;NotNull
  &#64;Override
  protected Actor buildActor(&#64;NotNull final String id, &#64;NotNull final Role role) throws Exception {
    return super.buildActor(id, new SupervisedRole(role));
  }
}
</pre>
</p>
<h2>Create a new Actor</h2>
<p>
    An Actor is usually instantiated through a Stage.
<pre class="brush:java">
stage.createActor(actorId, new Role() {

  &#64;NotNull
  &#64;Override
  public Behavior getBehavior(&#64;NotNull String id) throws Exception {
    return new AbstractBehavior() {

      &#64;Override
      public void onMessage(Object message, &#64;NotNull Envelop envelop, &#64;NotNull Agent agent) throws Exception {
        // do your stuff here
      }
    };
  }
});
</pre>
</p>
<p>
    Besides directly instantiating a Behavior, the Role class provides a builder employing
    functional interfaces to handle messages and start/stop events.
<pre class="brush:java">
stage.createActor(new Role() {

  &#64;NotNull
  &#64;Override
  public Behavior getBehavior(&#64;NotNull String id) throws Exception {
    BehaviorBuilder builder = newBehavior();
    // add your handlers here.
    return builder.build();
  }
});
</pre>
If no actor ID is specified, the Stage will create a new unique one.
</p>
</body>
</html>